"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRequest = void 0;
// This file is auto-generated, don't edit it
const gateway_spi_1 = __importDefault(require("@alicloud/gateway-spi"));
const tea_util_1 = __importDefault(require("@alicloud/tea-util"));
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const darabonba_encode_util_1 = __importDefault(require("@alicloud/darabonba-encode-util"));
const darabonba_signature_util_1 = __importDefault(require("@alicloud/darabonba-signature-util"));
const darabonba_string_1 = __importDefault(require("@alicloud/darabonba-string"));
const darabonba_map_1 = __importDefault(require("@alicloud/darabonba-map"));
const darabonba_array_1 = __importDefault(require("@alicloud/darabonba-array"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class HttpRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            path: 'path',
            headers: 'headers',
            body: 'body',
            reqBodyType: 'reqBodyType',
        };
    }
    static types() {
        return {
            method: 'string',
            path: 'string',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            body: 'Buffer',
            reqBodyType: 'string',
        };
    }
}
exports.HttpRequest = HttpRequest;
class Client extends gateway_spi_1.default {
    constructor() {
        super();
    }
    async modifyConfiguration(context, attributeMap) {
        let request = context.request;
        let config = context.configuration;
        config.endpoint = this.getEndpoint(request.productId, config.regionId, config.endpointRule, config.network, config.suffix, config.endpointMap, config.endpoint);
    }
    async modifyRequest(context, attributeMap) {
        let config = context.configuration;
        if (!darabonba_string_1.default.hasSuffix(config.endpoint, "aliyuncs.com")) {
            await this.signRequestForFc(context);
        }
        else {
            await this.signRequestForPop(context);
        }
    }
    async modifyResponse(context, attributeMap) {
        let request = context.request;
        let config = context.configuration;
        let response = context.response;
        if (tea_util_1.default.is4xx(response.statusCode) || tea_util_1.default.is5xx(response.statusCode)) {
            if (darabonba_string_1.default.hasPrefix(config.endpoint, "fc.") && darabonba_string_1.default.hasSuffix(config.endpoint, ".aliyuncs.com")) {
                let popRes = await tea_util_1.default.readAsJSON(response.body);
                let popErr = tea_util_1.default.assertAsMap(popRes);
                throw $tea.newError({
                    code: `${this.defaultAny(popErr["Code"], popErr["code"])}`,
                    message: `code: ${response.statusCode}, ${this.defaultAny(popErr["Message"], popErr["message"])} request id: ${this.defaultAny(popErr["RequestID"], popErr["RequestId"])}`,
                    data: popErr,
                });
            }
            else {
                let _headers = tea_util_1.default.assertAsMap(response.headers);
                let fcRes = await tea_util_1.default.readAsJSON(response.body);
                let fcErr = tea_util_1.default.assertAsMap(fcRes);
                throw $tea.newError({
                    code: fcErr["ErrorCode"],
                    message: `code: ${response.statusCode}, ${fcErr["ErrorMessage"]} request id: ${_headers["x-fc-request-id"]}`,
                    data: fcErr,
                });
            }
        }
        if (tea_util_1.default.equalString(request.bodyType, "binary")) {
            response.deserializedBody = response.body;
        }
        else if (tea_util_1.default.equalString(request.bodyType, "byte")) {
            let byt = await tea_util_1.default.readAsBytes(response.body);
            response.deserializedBody = byt;
        }
        else if (tea_util_1.default.equalString(request.bodyType, "string")) {
            let str = await tea_util_1.default.readAsString(response.body);
            response.deserializedBody = str;
        }
        else if (tea_util_1.default.equalString(request.bodyType, "json")) {
            let obj = await tea_util_1.default.readAsJSON(response.body);
            let res = tea_util_1.default.assertAsMap(obj);
            response.deserializedBody = res;
        }
        else if (tea_util_1.default.equalString(request.bodyType, "array")) {
            let arr = await tea_util_1.default.readAsJSON(response.body);
            response.deserializedBody = arr;
        }
        else {
            response.deserializedBody = await tea_util_1.default.readAsString(response.body);
        }
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    defaultAny(inputValue, defaultValue) {
        if (tea_util_1.default.isUnset(inputValue)) {
            return defaultValue;
        }
        return inputValue;
    }
    async signRequestForFc(context) {
        let request = context.request;
        let config = context.configuration;
        request.headers = Object.assign({ host: config.endpoint, date: tea_util_1.default.getDateUTCString(), accept: "application/json", 'user-agent': request.userAgent }, request.headers);
        request.headers["content-type"] = "application/json";
        if (!tea_util_1.default.isUnset(request.stream)) {
            let tmp = await tea_util_1.default.readAsBytes(request.stream);
            request.stream = new $tea.BytesReadable(tmp);
            request.headers["content-type"] = "application/octet-stream";
            request.headers["content-md5"] = darabonba_encode_util_1.default.base64EncodeToString(darabonba_signature_util_1.default.MD5SignForBytes(tmp));
        }
        else {
            if (!tea_util_1.default.isUnset(request.body)) {
                if (tea_util_1.default.equalString(request.reqBodyType, "json")) {
                    let jsonObj = tea_util_1.default.toJSONString(request.body);
                    request.stream = new $tea.BytesReadable(jsonObj);
                    request.headers["content-type"] = "application/json";
                    request.headers["content-md5"] = darabonba_encode_util_1.default.base64EncodeToString(darabonba_signature_util_1.default.MD5Sign(jsonObj));
                }
                else {
                    let m = tea_util_1.default.assertAsMap(request.body);
                    let formObj = openapi_util_1.default.toForm(m);
                    request.stream = new $tea.BytesReadable(formObj);
                    request.headers["content-type"] = "application/x-www-form-urlencoded";
                    request.headers["content-md5"] = darabonba_encode_util_1.default.base64EncodeToString(darabonba_signature_util_1.default.MD5Sign(formObj));
                }
            }
        }
        let credential = request.credential;
        let accessKeyId = await credential.getAccessKeyId();
        let accessKeySecret = await credential.getAccessKeySecret();
        let securityToken = await credential.getSecurityToken();
        if (!tea_util_1.default.empty(securityToken)) {
            request.headers["x-fc-security-token"] = securityToken;
        }
        request.headers["Authorization"] = await this.getAuthorizationForFc(request.pathname, request.method, request.query, request.headers, accessKeyId, accessKeySecret);
    }
    async signRequestForPop(context) {
        let request = context.request;
        let config = context.configuration;
        request.headers = Object.assign({ host: config.endpoint, 'x-acs-version': request.version, 'x-acs-action': request.action, 'user-agent': request.userAgent, 'x-acs-date': openapi_util_1.default.getTimestamp(), 'x-acs-signature-nonce': tea_util_1.default.getNonce(), accept: "application/json" }, request.headers);
        let signatureAlgorithm = "ACS3-HMAC-SHA256";
        if (!tea_util_1.default.isUnset(request.signatureAlgorithm)) {
            signatureAlgorithm = request.signatureAlgorithm;
        }
        let hashedRequestPayload = darabonba_encode_util_1.default.hexEncode(darabonba_encode_util_1.default.hash(tea_util_1.default.toBytes(""), signatureAlgorithm));
        if (!tea_util_1.default.isUnset(request.stream)) {
            let tmp = await tea_util_1.default.readAsBytes(request.stream);
            hashedRequestPayload = darabonba_encode_util_1.default.hexEncode(darabonba_encode_util_1.default.hash(tmp, signatureAlgorithm));
            request.stream = new $tea.BytesReadable(tmp);
            request.headers["content-type"] = "application/octet-stream";
        }
        else {
            if (!tea_util_1.default.isUnset(request.body)) {
                if (tea_util_1.default.equalString(request.reqBodyType, "json")) {
                    let jsonObj = tea_util_1.default.toJSONString(request.body);
                    hashedRequestPayload = darabonba_encode_util_1.default.hexEncode(darabonba_encode_util_1.default.hash(tea_util_1.default.toBytes(jsonObj), signatureAlgorithm));
                    request.stream = new $tea.BytesReadable(jsonObj);
                    request.headers["content-type"] = "application/json; charset=utf-8";
                }
                else {
                    let m = tea_util_1.default.assertAsMap(request.body);
                    let formObj = openapi_util_1.default.toForm(m);
                    hashedRequestPayload = darabonba_encode_util_1.default.hexEncode(darabonba_encode_util_1.default.hash(tea_util_1.default.toBytes(formObj), signatureAlgorithm));
                    request.stream = new $tea.BytesReadable(formObj);
                    request.headers["content-type"] = "application/x-www-form-urlencoded";
                }
            }
        }
        request.headers["x-acs-content-sha256"] = hashedRequestPayload;
        if (!tea_util_1.default.equalString(request.authType, "Anonymous")) {
            let credential = request.credential;
            let accessKeyId = await credential.getAccessKeyId();
            let accessKeySecret = await credential.getAccessKeySecret();
            let securityToken = await credential.getSecurityToken();
            if (!tea_util_1.default.empty(securityToken)) {
                request.headers["x-acs-accesskey-id"] = accessKeyId;
                request.headers["x-acs-security-token"] = securityToken;
            }
            request.headers["Authorization"] = await this.getAuthorizationForPop(request.pathname, request.method, request.query, request.headers, signatureAlgorithm, hashedRequestPayload, accessKeyId, accessKeySecret);
        }
    }
    async getAuthorizationForFc(pathname, method, query, headers, ak, secret) {
        let sign = await this.getSignatureForFc(pathname, method, query, headers, secret);
        return `FC ${ak}:${sign}`;
    }
    async getSignatureForFc(pathname, method, query, headers, secret) {
        let resource = pathname;
        let contentMd5 = headers["content-md5"];
        if (tea_util_1.default.isUnset(contentMd5)) {
            contentMd5 = "";
        }
        let contentType = headers["content-type"];
        if (tea_util_1.default.isUnset(contentType)) {
            contentType = "";
        }
        let stringToSign = "";
        let canonicalizedResource = await this.buildCanonicalizedResourceForFc(resource, query);
        let canonicalizedHeaders = await this.buildCanonicalizedHeadersForFc(headers);
        stringToSign = `${method}\n${contentMd5}\n${contentType}\n${headers["date"]}\n${canonicalizedHeaders}${canonicalizedResource}`;
        return darabonba_encode_util_1.default.base64EncodeToString(darabonba_signature_util_1.default.HmacSHA256Sign(stringToSign, secret));
    }
    async buildCanonicalizedResourceForFc(pathname, query) {
        let paths = darabonba_string_1.default.split(pathname, `?`, 2);
        let canonicalizedResource = paths[0];
        let resources = [];
        if (tea_util_1.default.equalNumber(darabonba_array_1.default.size(paths), 2)) {
            resources = darabonba_string_1.default.split(paths[1], "&", 0);
        }
        let subResources = [];
        let tmp = "";
        let separator = "";
        if (!tea_util_1.default.isUnset(query)) {
            let queryList = darabonba_map_1.default.keySet(query);
            for (let paramName of queryList) {
                tmp = `${tmp}${separator}${paramName}`;
                if (!tea_util_1.default.isUnset(query[paramName])) {
                    tmp = `${tmp}=${query[paramName]}`;
                }
                separator = ";";
            }
            subResources = darabonba_string_1.default.split(tmp, ";", 0);
        }
        let result = darabonba_array_1.default.concat(subResources, resources);
        let sortedParams = darabonba_array_1.default.ascSort(result);
        if (tea_util_1.default.equalNumber(darabonba_array_1.default.size(sortedParams), 0)) {
            return `${canonicalizedResource}\n`;
        }
        let subRes = darabonba_array_1.default.join(sortedParams, "\n");
        return `${canonicalizedResource}\n${subRes}`;
    }
    async buildCanonicalizedHeadersForFc(headers) {
        let canonicalizedHeaders = "";
        let keys = darabonba_map_1.default.keySet(headers);
        let sortedHeaders = darabonba_array_1.default.ascSort(keys);
        for (let header of sortedHeaders) {
            if (darabonba_string_1.default.contains(darabonba_string_1.default.toLower(header), "x-fc-")) {
                canonicalizedHeaders = `${canonicalizedHeaders}${darabonba_string_1.default.toLower(header)}:${headers[header]}\n`;
            }
        }
        return canonicalizedHeaders;
    }
    async getAuthorizationForPop(pathname, method, query, headers, signatureAlgorithm, payload, ak, secret) {
        let signature = await this.getSignatureForPop(pathname, method, query, headers, signatureAlgorithm, payload, secret);
        return `${signatureAlgorithm}  Credential=${ak},SignedHeaders=${darabonba_array_1.default.join(await this.getSignedHeaders(headers), ";")},Signature=${signature}`;
    }
    async getSignatureForPop(pathname, method, query, headers, signatureAlgorithm, payload, secret) {
        let canonicalURI = "/";
        if (!tea_util_1.default.empty(pathname)) {
            canonicalURI = pathname;
        }
        let stringToSign = "";
        let canonicalizedResource = await this.buildCanonicalizedResourceForPop(query);
        let canonicalizedHeaders = await this.buildCanonicalizedHeadersForPop(headers);
        let signedHeaders = await this.getSignedHeaders(headers);
        stringToSign = `${method}\n${canonicalURI}\n${canonicalizedResource}\n${canonicalizedHeaders}\n${darabonba_array_1.default.join(signedHeaders, ";")}\n${payload}`;
        let hex = darabonba_encode_util_1.default.hexEncode(darabonba_encode_util_1.default.hash(tea_util_1.default.toBytes(stringToSign), signatureAlgorithm));
        stringToSign = `${signatureAlgorithm}\n${hex}`;
        let signature = tea_util_1.default.toBytes("");
        if (darabonba_string_1.default.equals(signatureAlgorithm, "ACS3-HMAC-SHA256")) {
            signature = darabonba_signature_util_1.default.HmacSHA256Sign(stringToSign, secret);
        }
        else if (darabonba_string_1.default.equals(signatureAlgorithm, "ACS3-HMAC-SM3")) {
            signature = darabonba_signature_util_1.default.HmacSM3Sign(stringToSign, secret);
        }
        else if (darabonba_string_1.default.equals(signatureAlgorithm, "ACS3-RSA-SHA256")) {
            signature = darabonba_signature_util_1.default.SHA256withRSASign(stringToSign, secret);
        }
        return darabonba_encode_util_1.default.hexEncode(signature);
    }
    async buildCanonicalizedResourceForPop(query) {
        let canonicalizedResource = "";
        if (!tea_util_1.default.isUnset(query)) {
            let queryArray = darabonba_map_1.default.keySet(query);
            let sortedQueryArray = darabonba_array_1.default.ascSort(queryArray);
            for (let key of sortedQueryArray) {
                canonicalizedResource = `${canonicalizedResource}&${darabonba_encode_util_1.default.percentEncode(key)}`;
                if (!tea_util_1.default.empty(query[key])) {
                    canonicalizedResource = `${canonicalizedResource}=${darabonba_encode_util_1.default.percentEncode(query[key])}`;
                }
            }
        }
        return canonicalizedResource;
    }
    async buildCanonicalizedHeadersForPop(headers) {
        let canonicalizedHeaders = "";
        let sortedHeaders = await this.getSignedHeaders(headers);
        for (let header of sortedHeaders) {
            canonicalizedHeaders = `${canonicalizedHeaders}${header}:${darabonba_string_1.default.trim(headers[header])}\n`;
        }
        return canonicalizedHeaders;
    }
    async getSignedHeaders(headers) {
        let headersArray = darabonba_map_1.default.keySet(headers);
        let sortedHeadersArray = darabonba_array_1.default.ascSort(headersArray);
        let tmp = "";
        let separator = "";
        for (let key of sortedHeadersArray) {
            let lowerKey = darabonba_string_1.default.toLower(key);
            if (darabonba_string_1.default.hasPrefix(lowerKey, "x-acs-") || darabonba_string_1.default.equals(lowerKey, "host") || darabonba_string_1.default.equals(lowerKey, "content-type")) {
                if (!darabonba_string_1.default.contains(tmp, lowerKey)) {
                    tmp = `${tmp}${separator}${lowerKey}`;
                    separator = ";";
                }
            }
        }
        return darabonba_string_1.default.split(tmp, ";", 0);
    }
    async signRequest(request, credential) {
        let httpRequest = new HttpRequest({
            method: request.method,
            path: request.path,
            headers: request.headers,
            body: request.body,
            reqBodyType: request.reqBodyType,
        });
        httpRequest.headers["date"] = tea_util_1.default.getDateUTCString();
        httpRequest.headers["accept"] = "application/json";
        httpRequest.headers["content-type"] = "application/json";
        if (!tea_util_1.default.isUnset(request.body)) {
            if (tea_util_1.default.equalString(request.reqBodyType, "json")) {
                httpRequest.headers["content-type"] = "application/json";
            }
            else if (tea_util_1.default.equalString(request.reqBodyType, "form")) {
                httpRequest.headers["content-type"] = "application/x-www-form-urlencoded";
            }
            else if (tea_util_1.default.equalString(request.reqBodyType, "binary")) {
                httpRequest.headers["content-type"] = "application/octet-stream";
            }
        }
        let accessKeyId = await credential.getAccessKeyId();
        let accessKeySecret = await credential.getAccessKeySecret();
        let securityToken = await credential.getSecurityToken();
        if (!tea_util_1.default.empty(securityToken)) {
            httpRequest.headers["x-fc-security-token"] = securityToken;
        }
        let resource = request.path;
        let contentMd5 = httpRequest.headers["content-md5"];
        if (tea_util_1.default.isUnset(contentMd5)) {
            contentMd5 = "";
        }
        let contentType = httpRequest.headers["content-type"];
        if (tea_util_1.default.isUnset(contentType)) {
            contentType = "";
        }
        let stringToSign = "";
        let canonicalizedResource = await this.buildCanonicalizedResource(resource);
        let canonicalizedHeaders = await this.buildCanonicalizedHeaders(httpRequest.headers);
        stringToSign = `${request.method}\n${contentMd5}\n${contentType}\n${httpRequest.headers["date"]}\n${canonicalizedHeaders}${canonicalizedResource}`;
        let signature = darabonba_encode_util_1.default.base64EncodeToString(darabonba_signature_util_1.default.HmacSHA256Sign(stringToSign, accessKeySecret));
        httpRequest.headers["Authorization"] = `FC ${accessKeyId}:${signature}`;
        return httpRequest.headers;
    }
    async buildCanonicalizedResource(pathname) {
        let paths = darabonba_string_1.default.split(pathname, `?`, 2);
        let canonicalizedResource = paths[0];
        let resources = [];
        if (tea_util_1.default.equalNumber(darabonba_array_1.default.size(paths), 2)) {
            resources = darabonba_string_1.default.split(paths[1], "&", 0);
        }
        let sortedParams = darabonba_array_1.default.ascSort(resources);
        if (tea_util_1.default.equalNumber(darabonba_array_1.default.size(sortedParams), 0)) {
            return `${canonicalizedResource}\n`;
        }
        let subResources = darabonba_array_1.default.join(sortedParams, "\n");
        return `${canonicalizedResource}\n${subResources}`;
    }
    async buildCanonicalizedHeaders(headers) {
        let canonicalizedHeaders = "";
        let keys = darabonba_map_1.default.keySet(headers);
        let sortedHeaders = darabonba_array_1.default.ascSort(keys);
        for (let header of sortedHeaders) {
            if (darabonba_string_1.default.contains(darabonba_string_1.default.toLower(header), "x-fc-")) {
                canonicalizedHeaders = `${canonicalizedHeaders}${darabonba_string_1.default.toLower(header)}:${headers[header]}\n`;
            }
        }
        return canonicalizedHeaders;
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map