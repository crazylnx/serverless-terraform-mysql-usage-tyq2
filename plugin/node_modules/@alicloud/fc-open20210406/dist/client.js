"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AccelerationInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
}
exports.AccelerationInfo = AccelerationInfo;
class AsyncConfigMeta extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionName: 'functionName',
            qualifier: 'qualifier',
            serviceName: 'serviceName',
        };
    }
    static types() {
        return {
            functionName: 'string',
            qualifier: 'string',
            serviceName: 'string',
        };
    }
}
exports.AsyncConfigMeta = AsyncConfigMeta;
class AvailableAZ extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableAZs: 'availableAZs',
        };
    }
    static types() {
        return {
            availableAZs: 'string',
        };
    }
}
exports.AvailableAZ = AvailableAZ;
class CDNEventsTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventName: 'eventName',
            eventVersion: 'eventVersion',
            filter: 'filter',
            notes: 'notes',
        };
    }
    static types() {
        return {
            eventName: 'string',
            eventVersion: 'string',
            filter: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': 'string' } },
            notes: 'string',
        };
    }
}
exports.CDNEventsTriggerConfig = CDNEventsTriggerConfig;
class CertConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certName: 'certName',
            certificate: 'certificate',
            privateKey: 'privateKey',
        };
    }
    static types() {
        return {
            certName: 'string',
            certificate: 'string',
            privateKey: 'string',
        };
    }
}
exports.CertConfig = CertConfig;
class Code extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ossBucketName: 'ossBucketName',
            ossObjectName: 'ossObjectName',
            zipFile: 'zipFile',
        };
    }
    static types() {
        return {
            ossBucketName: 'string',
            ossObjectName: 'string',
            zipFile: 'string',
        };
    }
}
exports.Code = Code;
class CustomContainerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accelerationType: 'accelerationType',
            args: 'args',
            command: 'command',
            image: 'image',
            instanceID: 'instanceID',
        };
    }
    static types() {
        return {
            accelerationType: 'string',
            args: 'string',
            command: 'string',
            image: 'string',
            instanceID: 'string',
        };
    }
}
exports.CustomContainerConfig = CustomContainerConfig;
class CustomContainerConfigInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accelerationInfo: 'accelerationInfo',
            accelerationType: 'accelerationType',
            args: 'args',
            command: 'command',
            image: 'image',
            instanceID: 'instanceID',
        };
    }
    static types() {
        return {
            accelerationInfo: AccelerationInfo,
            accelerationType: 'string',
            args: 'string',
            command: 'string',
            image: 'string',
            instanceID: 'string',
        };
    }
}
exports.CustomContainerConfigInfo = CustomContainerConfigInfo;
class CustomDNS extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dnsOptions: 'dnsOptions',
            nameServers: 'nameServers',
            searches: 'searches',
        };
    }
    static types() {
        return {
            dnsOptions: { 'type': 'array', 'itemType': DNSOption },
            nameServers: { 'type': 'array', 'itemType': 'string' },
            searches: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CustomDNS = CustomDNS;
class CustomRuntimeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            args: 'args',
            command: 'command',
        };
    }
    static types() {
        return {
            args: { 'type': 'array', 'itemType': 'string' },
            command: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CustomRuntimeConfig = CustomRuntimeConfig;
class DNSOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
        };
    }
}
exports.DNSOption = DNSOption;
class Destination extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destination: 'destination',
        };
    }
    static types() {
        return {
            destination: 'string',
        };
    }
}
exports.Destination = Destination;
class DestinationConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            onFailure: 'onFailure',
            onSuccess: 'onSuccess',
        };
    }
    static types() {
        return {
            onFailure: Destination,
            onSuccess: Destination,
        };
    }
}
exports.DestinationConfig = DestinationConfig;
class Error extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMessage: 'errorMessage',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMessage: 'string',
        };
    }
}
exports.Error = Error;
class ErrorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorMessage: 'errorMessage',
            stackTrace: 'stackTrace',
        };
    }
    static types() {
        return {
            errorMessage: 'string',
            stackTrace: 'string',
        };
    }
}
exports.ErrorInfo = ErrorInfo;
class EventBridgeTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            asyncInvocationType: 'asyncInvocationType',
            eventRuleFilterPattern: 'eventRuleFilterPattern',
            eventSourceConfig: 'eventSourceConfig',
            triggerEnable: 'triggerEnable',
        };
    }
    static types() {
        return {
            asyncInvocationType: 'boolean',
            eventRuleFilterPattern: 'string',
            eventSourceConfig: EventSourceConfig,
            triggerEnable: 'boolean',
        };
    }
}
exports.EventBridgeTriggerConfig = EventBridgeTriggerConfig;
class EventSourceConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventSourceParameters: 'eventSourceParameters',
            eventSourceType: 'eventSourceType',
        };
    }
    static types() {
        return {
            eventSourceParameters: EventSourceParameters,
            eventSourceType: 'string',
        };
    }
}
exports.EventSourceConfig = EventSourceConfig;
class EventSourceParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            sourceMNSParameters: 'sourceMNSParameters',
            sourceRabbitMQParameters: 'sourceRabbitMQParameters',
            sourceRocketMQParameters: 'sourceRocketMQParameters',
        };
    }
    static types() {
        return {
            sourceMNSParameters: SourceMNSParameters,
            sourceRabbitMQParameters: SourceRabbitMQParameters,
            sourceRocketMQParameters: SourceRocketMQParameters,
        };
    }
}
exports.EventSourceParameters = EventSourceParameters;
class HTTPTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authType: 'authType',
            methods: 'methods',
        };
    }
    static types() {
        return {
            authType: 'string',
            methods: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.HTTPTriggerConfig = HTTPTriggerConfig;
class InstanceLifecycleConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            preFreeze: 'preFreeze',
            preStop: 'preStop',
        };
    }
    static types() {
        return {
            preFreeze: LifecycleHook,
            preStop: LifecycleHook,
        };
    }
}
exports.InstanceLifecycleConfig = InstanceLifecycleConfig;
class JaegerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endpoint: 'endpoint',
        };
    }
    static types() {
        return {
            endpoint: 'string',
        };
    }
}
exports.JaegerConfig = JaegerConfig;
class JobConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxRetryTime: 'maxRetryTime',
            triggerInterval: 'triggerInterval',
        };
    }
    static types() {
        return {
            maxRetryTime: 'number',
            triggerInterval: 'number',
        };
    }
}
exports.JobConfig = JobConfig;
class JobLogConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logstore: 'logstore',
            project: 'project',
        };
    }
    static types() {
        return {
            logstore: 'string',
            project: 'string',
        };
    }
}
exports.JobLogConfig = JobLogConfig;
class Layer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acl: 'acl',
            arn: 'arn',
            code: 'code',
            codeChecksum: 'codeChecksum',
            codeSize: 'codeSize',
            compatibleRuntime: 'compatibleRuntime',
            createTime: 'createTime',
            description: 'description',
            layerName: 'layerName',
            version: 'version',
        };
    }
    static types() {
        return {
            acl: 'number',
            arn: 'string',
            code: LayerCode,
            codeChecksum: 'string',
            codeSize: 'number',
            compatibleRuntime: { 'type': 'array', 'itemType': 'string' },
            createTime: 'string',
            description: 'string',
            layerName: 'string',
            version: 'number',
        };
    }
}
exports.Layer = Layer;
class LayerCode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            location: 'location',
            repositoryType: 'repositoryType',
        };
    }
    static types() {
        return {
            location: 'string',
            repositoryType: 'string',
        };
    }
}
exports.LayerCode = LayerCode;
class LifecycleHook extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            handler: 'handler',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            handler: 'string',
            timeout: 'number',
        };
    }
}
exports.LifecycleHook = LifecycleHook;
class LogConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableInstanceMetrics: 'enableInstanceMetrics',
            enableRequestMetrics: 'enableRequestMetrics',
            logBeginRule: 'logBeginRule',
            logstore: 'logstore',
            project: 'project',
        };
    }
    static types() {
        return {
            enableInstanceMetrics: 'boolean',
            enableRequestMetrics: 'boolean',
            logBeginRule: 'string',
            logstore: 'string',
            project: 'string',
        };
    }
}
exports.LogConfig = LogConfig;
class LogTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enable: 'enable',
            functionParameter: 'functionParameter',
            jobConfig: 'jobConfig',
            logConfig: 'logConfig',
            sourceConfig: 'sourceConfig',
        };
    }
    static types() {
        return {
            enable: 'boolean',
            functionParameter: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            jobConfig: JobConfig,
            logConfig: JobLogConfig,
            sourceConfig: SourceConfig,
        };
    }
}
exports.LogTriggerConfig = LogTriggerConfig;
class MeteringConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logConfig: 'logConfig',
            payerId: 'payerId',
            role: 'role',
        };
    }
    static types() {
        return {
            logConfig: LogConfig,
            payerId: 'string',
            role: 'string',
        };
    }
}
exports.MeteringConfig = MeteringConfig;
class MnsTopicTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filterTag: 'filterTag',
            notifyContentFormat: 'notifyContentFormat',
            notifyStrategy: 'notifyStrategy',
        };
    }
    static types() {
        return {
            filterTag: 'string',
            notifyContentFormat: 'string',
            notifyStrategy: 'string',
        };
    }
}
exports.MnsTopicTriggerConfig = MnsTopicTriggerConfig;
class NASConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'groupId',
            mountPoints: 'mountPoints',
            userId: 'userId',
        };
    }
    static types() {
        return {
            groupId: 'number',
            mountPoints: { 'type': 'array', 'itemType': NASConfigMountPoints },
            userId: 'number',
        };
    }
}
exports.NASConfig = NASConfig;
class OSSTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            events: 'events',
            filter: 'filter',
        };
    }
    static types() {
        return {
            events: { 'type': 'array', 'itemType': 'string' },
            filter: OSSTriggerFilter,
        };
    }
}
exports.OSSTriggerConfig = OSSTriggerConfig;
class OSSTriggerFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
        };
    }
    static types() {
        return {
            key: OSSTriggerKey,
        };
    }
}
exports.OSSTriggerFilter = OSSTriggerFilter;
class OSSTriggerKey extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            prefix: 'prefix',
            suffix: 'suffix',
        };
    }
    static types() {
        return {
            prefix: 'string',
            suffix: 'string',
        };
    }
}
exports.OSSTriggerKey = OSSTriggerKey;
class OnDemandConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maximumInstanceCount: 'maximumInstanceCount',
            resource: 'resource',
        };
    }
    static types() {
        return {
            maximumInstanceCount: 'number',
            resource: 'string',
        };
    }
}
exports.OnDemandConfig = OnDemandConfig;
class OpenReservedCapacity extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            cu: 'cu',
            deadline: 'deadline',
            instanceId: 'instanceId',
            isRefunded: 'isRefunded',
            lastModifiedTime: 'lastModifiedTime',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            cu: 'number',
            deadline: 'string',
            instanceId: 'string',
            isRefunded: 'string',
            lastModifiedTime: 'string',
        };
    }
}
exports.OpenReservedCapacity = OpenReservedCapacity;
class OutputCodeLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            location: 'location',
            repositoryType: 'repositoryType',
        };
    }
    static types() {
        return {
            location: 'string',
            repositoryType: 'string',
        };
    }
}
exports.OutputCodeLocation = OutputCodeLocation;
class PathConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functionName: 'functionName',
            methods: 'methods',
            path: 'path',
            qualifier: 'qualifier',
            serviceName: 'serviceName',
        };
    }
    static types() {
        return {
            functionName: 'string',
            methods: { 'type': 'array', 'itemType': 'string' },
            path: 'string',
            qualifier: 'string',
            serviceName: 'string',
        };
    }
}
exports.PathConfig = PathConfig;
class PreFreeze extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            handler: 'handler',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            handler: 'string',
            timeout: 'number',
        };
    }
}
exports.PreFreeze = PreFreeze;
class PreStop extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            handler: 'handler',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            handler: 'string',
            timeout: 'number',
        };
    }
}
exports.PreStop = PreStop;
class RdsTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            concurrency: 'concurrency',
            eventFormat: 'eventFormat',
            retry: 'retry',
            subscriptionObjects: 'subscriptionObjects',
        };
    }
    static types() {
        return {
            concurrency: 'number',
            eventFormat: 'string',
            retry: 'number',
            subscriptionObjects: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RdsTriggerConfig = RdsTriggerConfig;
class Resource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceArn: 'resourceArn',
            tags: 'tags',
        };
    }
    static types() {
        return {
            resourceArn: 'string',
            tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.Resource = Resource;
class RouteConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            routes: 'routes',
        };
    }
    static types() {
        return {
            routes: { 'type': 'array', 'itemType': PathConfig },
        };
    }
}
exports.RouteConfig = RouteConfig;
class ScheduledActions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            name: 'name',
            scheduleExpression: 'scheduleExpression',
            startTime: 'startTime',
            target: 'target',
        };
    }
    static types() {
        return {
            endTime: 'string',
            name: 'string',
            scheduleExpression: 'string',
            startTime: 'string',
            target: 'number',
        };
    }
}
exports.ScheduledActions = ScheduledActions;
class SourceConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logstore: 'logstore',
        };
    }
    static types() {
        return {
            logstore: 'string',
        };
    }
}
exports.SourceConfig = SourceConfig;
class SourceMNSParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isBase64Decode: 'IsBase64Decode',
            queueName: 'QueueName',
            regionId: 'RegionId',
        };
    }
    static types() {
        return {
            isBase64Decode: 'boolean',
            queueName: 'string',
            regionId: 'string',
        };
    }
}
exports.SourceMNSParameters = SourceMNSParameters;
class SourceRabbitMQParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'InstanceId',
            queueName: 'QueueName',
            regionId: 'RegionId',
            virtualHostName: 'VirtualHostName',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            queueName: 'string',
            regionId: 'string',
            virtualHostName: 'string',
        };
    }
}
exports.SourceRabbitMQParameters = SourceRabbitMQParameters;
class SourceRocketMQParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupID: 'GroupID',
            instanceId: 'InstanceId',
            offset: 'Offset',
            regionId: 'RegionId',
            tag: 'Tag',
            timestamp: 'Timestamp',
            topic: 'Topic',
        };
    }
    static types() {
        return {
            groupID: 'string',
            instanceId: 'string',
            offset: 'string',
            regionId: 'string',
            tag: 'string',
            timestamp: 'number',
            topic: 'string',
        };
    }
}
exports.SourceRocketMQParameters = SourceRocketMQParameters;
class StatefulAsyncInvocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alreadyRetriedTimes: 'alreadyRetriedTimes',
            destinationStatus: 'destinationStatus',
            endTime: 'endTime',
            events: 'events',
            functionName: 'functionName',
            instanceId: 'instanceId',
            invocationErrorMessage: 'invocationErrorMessage',
            invocationId: 'invocationId',
            invocationPayload: 'invocationPayload',
            qualifier: 'qualifier',
            requestId: 'requestId',
            serviceName: 'serviceName',
            startedTime: 'startedTime',
            status: 'status',
        };
    }
    static types() {
        return {
            alreadyRetriedTimes: 'number',
            destinationStatus: 'string',
            endTime: 'number',
            events: { 'type': 'array', 'itemType': StatefulAsyncInvocationEvent },
            functionName: 'string',
            instanceId: 'string',
            invocationErrorMessage: 'string',
            invocationId: 'string',
            invocationPayload: 'string',
            qualifier: 'string',
            requestId: 'string',
            serviceName: 'string',
            startedTime: 'number',
            status: 'string',
        };
    }
}
exports.StatefulAsyncInvocation = StatefulAsyncInvocation;
class StatefulAsyncInvocationEvent extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventDetail: 'eventDetail',
            eventId: 'eventId',
            status: 'status',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            eventDetail: 'string',
            eventId: 'number',
            status: 'string',
            timestamp: 'number',
        };
    }
}
exports.StatefulAsyncInvocationEvent = StatefulAsyncInvocationEvent;
class TLSConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cipherSuites: 'cipherSuites',
            maxVersion: 'maxVersion',
            minVersion: 'minVersion',
        };
    }
    static types() {
        return {
            cipherSuites: { 'type': 'array', 'itemType': 'string' },
            maxVersion: 'string',
            minVersion: 'string',
        };
    }
}
exports.TLSConfig = TLSConfig;
class TargetTrackingPolicies extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            maxCapacity: 'maxCapacity',
            metricTarget: 'metricTarget',
            metricType: 'metricType',
            minCapacity: 'minCapacity',
            name: 'name',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            endTime: 'string',
            maxCapacity: 'number',
            metricTarget: 'number',
            metricType: 'string',
            minCapacity: 'number',
            name: 'string',
            startTime: 'string',
        };
    }
}
exports.TargetTrackingPolicies = TargetTrackingPolicies;
class TimeTriggerConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cronExpression: 'cronExpression',
            enable: 'enable',
            payload: 'payload',
        };
    }
    static types() {
        return {
            cronExpression: 'string',
            enable: 'boolean',
            payload: 'string',
        };
    }
}
exports.TimeTriggerConfig = TimeTriggerConfig;
class TracingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            params: 'params',
            type: 'type',
        };
    }
    static types() {
        return {
            params: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            type: 'string',
        };
    }
}
exports.TracingConfig = TracingConfig;
class VPCConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            role: 'role',
            securityGroupId: 'securityGroupId',
            vSwitchIds: 'vSwitchIds',
            vpcId: 'vpcId',
        };
    }
    static types() {
        return {
            role: 'string',
            securityGroupId: 'string',
            vSwitchIds: { 'type': 'array', 'itemType': 'string' },
            vpcId: 'string',
        };
    }
}
exports.VPCConfig = VPCConfig;
class VendorConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            meteringConfig: 'meteringConfig',
        };
    }
    static types() {
        return {
            meteringConfig: MeteringConfig,
        };
    }
}
exports.VendorConfig = VendorConfig;
class CreateAliasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateAliasHeaders = CreateAliasHeaders;
class CreateAliasRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalVersionWeight: 'additionalVersionWeight',
            aliasName: 'aliasName',
            description: 'description',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
            aliasName: 'string',
            description: 'string',
            versionId: 'string',
        };
    }
}
exports.CreateAliasRequest = CreateAliasRequest;
class CreateAliasResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalVersionWeight: 'additionalVersionWeight',
            aliasName: 'aliasName',
            createdTime: 'createdTime',
            description: 'description',
            lastModifiedTime: 'lastModifiedTime',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
            aliasName: 'string',
            createdTime: 'string',
            description: 'string',
            lastModifiedTime: 'string',
            versionId: 'string',
        };
    }
}
exports.CreateAliasResponseBody = CreateAliasResponseBody;
class CreateAliasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAliasResponseBody,
        };
    }
}
exports.CreateAliasResponse = CreateAliasResponse;
class CreateCustomDomainHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateCustomDomainHeaders = CreateCustomDomainHeaders;
class CreateCustomDomainRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certConfig: 'certConfig',
            domainName: 'domainName',
            protocol: 'protocol',
            routeConfig: 'routeConfig',
            tlsConfig: 'tlsConfig',
        };
    }
    static types() {
        return {
            certConfig: CertConfig,
            domainName: 'string',
            protocol: 'string',
            routeConfig: RouteConfig,
            tlsConfig: TLSConfig,
        };
    }
}
exports.CreateCustomDomainRequest = CreateCustomDomainRequest;
class CreateCustomDomainResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            apiVersion: 'apiVersion',
            certConfig: 'certConfig',
            createdTime: 'createdTime',
            domainName: 'domainName',
            lastModifiedTime: 'lastModifiedTime',
            protocol: 'protocol',
            routeConfig: 'routeConfig',
            tlsConfig: 'tlsConfig',
        };
    }
    static types() {
        return {
            accountId: 'string',
            apiVersion: 'string',
            certConfig: CertConfig,
            createdTime: 'string',
            domainName: 'string',
            lastModifiedTime: 'string',
            protocol: 'string',
            routeConfig: RouteConfig,
            tlsConfig: TLSConfig,
        };
    }
}
exports.CreateCustomDomainResponseBody = CreateCustomDomainResponseBody;
class CreateCustomDomainResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCustomDomainResponseBody,
        };
    }
}
exports.CreateCustomDomainResponse = CreateCustomDomainResponse;
class CreateFunctionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcCodeChecksum: 'X-Fc-Code-Checksum',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcCodeChecksum: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateFunctionHeaders = CreateFunctionHeaders;
class CreateFunctionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            caPort: 'caPort',
            code: 'code',
            customContainerConfig: 'customContainerConfig',
            customDNS: 'customDNS',
            customRuntimeConfig: 'customRuntimeConfig',
            description: 'description',
            environmentVariables: 'environmentVariables',
            functionName: 'functionName',
            handler: 'handler',
            initializationTimeout: 'initializationTimeout',
            initializer: 'initializer',
            instanceConcurrency: 'instanceConcurrency',
            instanceLifecycleConfig: 'instanceLifecycleConfig',
            instanceSoftConcurrency: 'instanceSoftConcurrency',
            instanceType: 'instanceType',
            layers: 'layers',
            memorySize: 'memorySize',
            runtime: 'runtime',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            caPort: 'number',
            code: Code,
            customContainerConfig: CustomContainerConfig,
            customDNS: CustomDNS,
            customRuntimeConfig: CustomRuntimeConfig,
            description: 'string',
            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            functionName: 'string',
            handler: 'string',
            initializationTimeout: 'number',
            initializer: 'string',
            instanceConcurrency: 'number',
            instanceLifecycleConfig: InstanceLifecycleConfig,
            instanceSoftConcurrency: 'number',
            instanceType: 'string',
            layers: { 'type': 'array', 'itemType': 'string' },
            memorySize: 'number',
            runtime: 'string',
            timeout: 'number',
        };
    }
}
exports.CreateFunctionRequest = CreateFunctionRequest;
class CreateFunctionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            caPort: 'caPort',
            codeChecksum: 'codeChecksum',
            codeSize: 'codeSize',
            createdTime: 'createdTime',
            customContainerConfig: 'customContainerConfig',
            customDNS: 'customDNS',
            customRuntimeConfig: 'customRuntimeConfig',
            description: 'description',
            environmentVariables: 'environmentVariables',
            functionId: 'functionId',
            functionName: 'functionName',
            handler: 'handler',
            initializationTimeout: 'initializationTimeout',
            initializer: 'initializer',
            instanceConcurrency: 'instanceConcurrency',
            instanceLifecycleConfig: 'instanceLifecycleConfig',
            instanceSoftConcurrency: 'instanceSoftConcurrency',
            instanceType: 'instanceType',
            lastModifiedTime: 'lastModifiedTime',
            layers: 'layers',
            memorySize: 'memorySize',
            runtime: 'runtime',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            caPort: 'number',
            codeChecksum: 'string',
            codeSize: 'number',
            createdTime: 'string',
            customContainerConfig: CustomContainerConfig,
            customDNS: CustomDNS,
            customRuntimeConfig: CustomRuntimeConfig,
            description: 'string',
            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            functionId: 'string',
            functionName: 'string',
            handler: 'string',
            initializationTimeout: 'number',
            initializer: 'string',
            instanceConcurrency: 'number',
            instanceLifecycleConfig: InstanceLifecycleConfig,
            instanceSoftConcurrency: 'number',
            instanceType: 'string',
            lastModifiedTime: 'string',
            layers: { 'type': 'array', 'itemType': 'string' },
            memorySize: 'number',
            runtime: 'string',
            timeout: 'number',
        };
    }
}
exports.CreateFunctionResponseBody = CreateFunctionResponseBody;
class CreateFunctionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateFunctionResponseBody,
        };
    }
}
exports.CreateFunctionResponse = CreateFunctionResponse;
class CreateLayerVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateLayerVersionHeaders = CreateLayerVersionHeaders;
class CreateLayerVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            compatibleRuntime: 'compatibleRuntime',
            description: 'description',
        };
    }
    static types() {
        return {
            code: Code,
            compatibleRuntime: { 'type': 'array', 'itemType': 'string' },
            description: 'string',
        };
    }
}
exports.CreateLayerVersionRequest = CreateLayerVersionRequest;
class CreateLayerVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acl: 'acl',
            arn: 'arn',
            code: 'code',
            codeChecksum: 'codeChecksum',
            codesize: 'codesize',
            compatibleRuntime: 'compatibleRuntime',
            createTime: 'createTime',
            description: 'description',
            layerName: 'layerName',
            version: 'version',
        };
    }
    static types() {
        return {
            acl: 'number',
            arn: 'string',
            code: OutputCodeLocation,
            codeChecksum: 'string',
            codesize: 'number',
            compatibleRuntime: { 'type': 'array', 'itemType': 'string' },
            createTime: 'string',
            description: 'string',
            layerName: 'string',
            version: 'number',
        };
    }
}
exports.CreateLayerVersionResponseBody = CreateLayerVersionResponseBody;
class CreateLayerVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateLayerVersionResponseBody,
        };
    }
}
exports.CreateLayerVersionResponse = CreateLayerVersionResponse;
class CreateServiceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateServiceHeaders = CreateServiceHeaders;
class CreateServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            internetAccess: 'internetAccess',
            logConfig: 'logConfig',
            nasConfig: 'nasConfig',
            role: 'role',
            serviceName: 'serviceName',
            tracingConfig: 'tracingConfig',
            vpcConfig: 'vpcConfig',
        };
    }
    static types() {
        return {
            description: 'string',
            internetAccess: 'boolean',
            logConfig: LogConfig,
            nasConfig: NASConfig,
            role: 'string',
            serviceName: 'string',
            tracingConfig: TracingConfig,
            vpcConfig: VPCConfig,
        };
    }
}
exports.CreateServiceRequest = CreateServiceRequest;
class CreateServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            internetAccess: 'internetAccess',
            lastModifiedTime: 'lastModifiedTime',
            logConfig: 'logConfig',
            nasConfig: 'nasConfig',
            role: 'role',
            serviceId: 'serviceId',
            serviceName: 'serviceName',
            tracingConfig: 'tracingConfig',
            vendorConfig: 'vendorConfig',
            vpcConfig: 'vpcConfig',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            internetAccess: 'boolean',
            lastModifiedTime: 'string',
            logConfig: LogConfig,
            nasConfig: NASConfig,
            role: 'string',
            serviceId: 'string',
            serviceName: 'string',
            tracingConfig: TracingConfig,
            vendorConfig: VendorConfig,
            vpcConfig: VPCConfig,
        };
    }
}
exports.CreateServiceResponseBody = CreateServiceResponseBody;
class CreateServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateServiceResponseBody,
        };
    }
}
exports.CreateServiceResponse = CreateServiceResponse;
class CreateTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateTriggerHeaders = CreateTriggerHeaders;
class CreateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            invocationRole: 'invocationRole',
            qualifier: 'qualifier',
            sourceArn: 'sourceArn',
            triggerConfig: 'triggerConfig',
            triggerName: 'triggerName',
            triggerType: 'triggerType',
        };
    }
    static types() {
        return {
            description: 'string',
            invocationRole: 'string',
            qualifier: 'string',
            sourceArn: 'string',
            triggerConfig: 'string',
            triggerName: 'string',
            triggerType: 'string',
        };
    }
}
exports.CreateTriggerRequest = CreateTriggerRequest;
class CreateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            domainName: 'domainName',
            invocationRole: 'invocationRole',
            lastModifiedTime: 'lastModifiedTime',
            qualifier: 'qualifier',
            sourceArn: 'sourceArn',
            triggerConfig: 'triggerConfig',
            triggerId: 'triggerId',
            triggerName: 'triggerName',
            triggerType: 'triggerType',
            urlInternet: 'urlInternet',
            urlIntranet: 'urlIntranet',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            domainName: 'string',
            invocationRole: 'string',
            lastModifiedTime: 'string',
            qualifier: 'string',
            sourceArn: 'string',
            triggerConfig: 'string',
            triggerId: 'string',
            triggerName: 'string',
            triggerType: 'string',
            urlInternet: 'string',
            urlIntranet: 'string',
        };
    }
}
exports.CreateTriggerResponseBody = CreateTriggerResponseBody;
class CreateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTriggerResponseBody,
        };
    }
}
exports.CreateTriggerResponse = CreateTriggerResponse;
class CreateVpcBindingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.CreateVpcBindingHeaders = CreateVpcBindingHeaders;
class CreateVpcBindingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            vpcId: 'vpcId',
        };
    }
    static types() {
        return {
            vpcId: 'string',
        };
    }
}
exports.CreateVpcBindingRequest = CreateVpcBindingRequest;
class CreateVpcBindingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.CreateVpcBindingResponse = CreateVpcBindingResponse;
class DeleteAliasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteAliasHeaders = DeleteAliasHeaders;
class DeleteAliasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteAliasResponse = DeleteAliasResponse;
class DeleteCustomDomainHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteCustomDomainHeaders = DeleteCustomDomainHeaders;
class DeleteCustomDomainResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteCustomDomainResponse = DeleteCustomDomainResponse;
class DeleteFunctionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteFunctionHeaders = DeleteFunctionHeaders;
class DeleteFunctionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteFunctionResponse = DeleteFunctionResponse;
class DeleteFunctionAsyncInvokeConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteFunctionAsyncInvokeConfigHeaders = DeleteFunctionAsyncInvokeConfigHeaders;
class DeleteFunctionAsyncInvokeConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.DeleteFunctionAsyncInvokeConfigRequest = DeleteFunctionAsyncInvokeConfigRequest;
class DeleteFunctionAsyncInvokeConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteFunctionAsyncInvokeConfigResponse = DeleteFunctionAsyncInvokeConfigResponse;
class DeleteFunctionOnDemandConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteFunctionOnDemandConfigHeaders = DeleteFunctionOnDemandConfigHeaders;
class DeleteFunctionOnDemandConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.DeleteFunctionOnDemandConfigRequest = DeleteFunctionOnDemandConfigRequest;
class DeleteFunctionOnDemandConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteFunctionOnDemandConfigResponse = DeleteFunctionOnDemandConfigResponse;
class DeleteLayerVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteLayerVersionHeaders = DeleteLayerVersionHeaders;
class DeleteLayerVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteLayerVersionResponse = DeleteLayerVersionResponse;
class DeleteServiceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteServiceHeaders = DeleteServiceHeaders;
class DeleteServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteServiceResponse = DeleteServiceResponse;
class DeleteServiceVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteServiceVersionHeaders = DeleteServiceVersionHeaders;
class DeleteServiceVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteServiceVersionResponse = DeleteServiceVersionResponse;
class DeleteTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteTriggerHeaders = DeleteTriggerHeaders;
class DeleteTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteTriggerResponse = DeleteTriggerResponse;
class DeleteVpcBindingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeleteVpcBindingHeaders = DeleteVpcBindingHeaders;
class DeleteVpcBindingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteVpcBindingResponse = DeleteVpcBindingResponse;
class DeregisterEventSourceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.DeregisterEventSourceHeaders = DeregisterEventSourceHeaders;
class DeregisterEventSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.DeregisterEventSourceRequest = DeregisterEventSourceRequest;
class DeregisterEventSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeregisterEventSourceResponse = DeregisterEventSourceResponse;
class GetAccountSettingsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetAccountSettingsHeaders = GetAccountSettingsHeaders;
class GetAccountSettingsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableAZs: 'availableAZs',
            defaultRole: 'defaultRole',
        };
    }
    static types() {
        return {
            availableAZs: { 'type': 'array', 'itemType': 'string' },
            defaultRole: 'string',
        };
    }
}
exports.GetAccountSettingsResponseBody = GetAccountSettingsResponseBody;
class GetAccountSettingsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAccountSettingsResponseBody,
        };
    }
}
exports.GetAccountSettingsResponse = GetAccountSettingsResponse;
class GetAliasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetAliasHeaders = GetAliasHeaders;
class GetAliasResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalVersionWeight: 'additionalVersionWeight',
            aliasName: 'aliasName',
            createdTime: 'createdTime',
            description: 'description',
            lastModifiedTime: 'lastModifiedTime',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
            aliasName: 'string',
            createdTime: 'string',
            description: 'string',
            lastModifiedTime: 'string',
            versionId: 'string',
        };
    }
}
exports.GetAliasResponseBody = GetAliasResponseBody;
class GetAliasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAliasResponseBody,
        };
    }
}
exports.GetAliasResponse = GetAliasResponse;
class GetCustomDomainHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetCustomDomainHeaders = GetCustomDomainHeaders;
class GetCustomDomainResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            apiVersion: 'apiVersion',
            certConfig: 'certConfig',
            createdTime: 'createdTime',
            domainName: 'domainName',
            lastModifiedTime: 'lastModifiedTime',
            protocol: 'protocol',
            routeConfig: 'routeConfig',
            tlsConfig: 'tlsConfig',
        };
    }
    static types() {
        return {
            accountId: 'string',
            apiVersion: 'string',
            certConfig: CertConfig,
            createdTime: 'string',
            domainName: 'string',
            lastModifiedTime: 'string',
            protocol: 'string',
            routeConfig: RouteConfig,
            tlsConfig: TLSConfig,
        };
    }
}
exports.GetCustomDomainResponseBody = GetCustomDomainResponseBody;
class GetCustomDomainResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCustomDomainResponseBody,
        };
    }
}
exports.GetCustomDomainResponse = GetCustomDomainResponse;
class GetFunctionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetFunctionHeaders = GetFunctionHeaders;
class GetFunctionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetFunctionRequest = GetFunctionRequest;
class GetFunctionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            caPort: 'caPort',
            codeChecksum: 'codeChecksum',
            codeSize: 'codeSize',
            createdTime: 'createdTime',
            customContainerConfig: 'customContainerConfig',
            customDNS: 'customDNS',
            customRuntimeConfig: 'customRuntimeConfig',
            description: 'description',
            environmentVariables: 'environmentVariables',
            functionId: 'functionId',
            functionName: 'functionName',
            handler: 'handler',
            initializationTimeout: 'initializationTimeout',
            initializer: 'initializer',
            instanceConcurrency: 'instanceConcurrency',
            instanceLifecycleConfig: 'instanceLifecycleConfig',
            instanceSoftConcurrency: 'instanceSoftConcurrency',
            instanceType: 'instanceType',
            lastModifiedTime: 'lastModifiedTime',
            layers: 'layers',
            memorySize: 'memorySize',
            runtime: 'runtime',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            caPort: 'number',
            codeChecksum: 'string',
            codeSize: 'number',
            createdTime: 'string',
            customContainerConfig: CustomContainerConfigInfo,
            customDNS: CustomDNS,
            customRuntimeConfig: CustomRuntimeConfig,
            description: 'string',
            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            functionId: 'string',
            functionName: 'string',
            handler: 'string',
            initializationTimeout: 'number',
            initializer: 'string',
            instanceConcurrency: 'number',
            instanceLifecycleConfig: InstanceLifecycleConfig,
            instanceSoftConcurrency: 'number',
            instanceType: 'string',
            lastModifiedTime: 'string',
            layers: { 'type': 'array', 'itemType': 'string' },
            memorySize: 'number',
            runtime: 'string',
            timeout: 'number',
        };
    }
}
exports.GetFunctionResponseBody = GetFunctionResponseBody;
class GetFunctionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFunctionResponseBody,
        };
    }
}
exports.GetFunctionResponse = GetFunctionResponse;
class GetFunctionAsyncInvokeConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetFunctionAsyncInvokeConfigHeaders = GetFunctionAsyncInvokeConfigHeaders;
class GetFunctionAsyncInvokeConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetFunctionAsyncInvokeConfigRequest = GetFunctionAsyncInvokeConfigRequest;
class GetFunctionAsyncInvokeConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            destinationConfig: 'destinationConfig',
            function: 'function',
            lastModifiedTime: 'lastModifiedTime',
            maxAsyncEventAgeInSeconds: 'maxAsyncEventAgeInSeconds',
            maxAsyncRetryAttempts: 'maxAsyncRetryAttempts',
            qualifier: 'qualifier',
            service: 'service',
            statefulInvocation: 'statefulInvocation',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            destinationConfig: DestinationConfig,
            function: 'string',
            lastModifiedTime: 'string',
            maxAsyncEventAgeInSeconds: 'number',
            maxAsyncRetryAttempts: 'number',
            qualifier: 'string',
            service: 'string',
            statefulInvocation: 'boolean',
        };
    }
}
exports.GetFunctionAsyncInvokeConfigResponseBody = GetFunctionAsyncInvokeConfigResponseBody;
class GetFunctionAsyncInvokeConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFunctionAsyncInvokeConfigResponseBody,
        };
    }
}
exports.GetFunctionAsyncInvokeConfigResponse = GetFunctionAsyncInvokeConfigResponse;
class GetFunctionCodeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetFunctionCodeHeaders = GetFunctionCodeHeaders;
class GetFunctionCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetFunctionCodeRequest = GetFunctionCodeRequest;
class GetFunctionCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checksum: 'checksum',
            url: 'url',
        };
    }
    static types() {
        return {
            checksum: 'string',
            url: 'string',
        };
    }
}
exports.GetFunctionCodeResponseBody = GetFunctionCodeResponseBody;
class GetFunctionCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFunctionCodeResponseBody,
        };
    }
}
exports.GetFunctionCodeResponse = GetFunctionCodeResponse;
class GetFunctionOnDemandConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetFunctionOnDemandConfigHeaders = GetFunctionOnDemandConfigHeaders;
class GetFunctionOnDemandConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetFunctionOnDemandConfigRequest = GetFunctionOnDemandConfigRequest;
class GetFunctionOnDemandConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maximumInstanceCount: 'maximumInstanceCount',
            resource: 'resource',
        };
    }
    static types() {
        return {
            maximumInstanceCount: 'number',
            resource: 'string',
        };
    }
}
exports.GetFunctionOnDemandConfigResponseBody = GetFunctionOnDemandConfigResponseBody;
class GetFunctionOnDemandConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFunctionOnDemandConfigResponseBody,
        };
    }
}
exports.GetFunctionOnDemandConfigResponse = GetFunctionOnDemandConfigResponse;
class GetLayerVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetLayerVersionHeaders = GetLayerVersionHeaders;
class GetLayerVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: Layer,
        };
    }
}
exports.GetLayerVersionResponse = GetLayerVersionResponse;
class GetProvisionConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetProvisionConfigHeaders = GetProvisionConfigHeaders;
class GetProvisionConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetProvisionConfigRequest = GetProvisionConfigRequest;
class GetProvisionConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alwaysAllocateCPU: 'alwaysAllocateCPU',
            current: 'current',
            currentError: 'currentError',
            resource: 'resource',
            scheduledActions: 'scheduledActions',
            target: 'target',
            targetTrackingPolicies: 'targetTrackingPolicies',
        };
    }
    static types() {
        return {
            alwaysAllocateCPU: 'boolean',
            current: 'number',
            currentError: 'string',
            resource: 'string',
            scheduledActions: { 'type': 'array', 'itemType': ScheduledActions },
            target: 'number',
            targetTrackingPolicies: { 'type': 'array', 'itemType': TargetTrackingPolicies },
        };
    }
}
exports.GetProvisionConfigResponseBody = GetProvisionConfigResponseBody;
class GetProvisionConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetProvisionConfigResponseBody,
        };
    }
}
exports.GetProvisionConfigResponse = GetProvisionConfigResponse;
class GetResourceTagsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetResourceTagsHeaders = GetResourceTagsHeaders;
class GetResourceTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceArn: 'resourceArn',
        };
    }
    static types() {
        return {
            resourceArn: 'string',
        };
    }
}
exports.GetResourceTagsRequest = GetResourceTagsRequest;
class GetResourceTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceArn: 'resourceArn',
            tags: 'tags',
        };
    }
    static types() {
        return {
            resourceArn: 'string',
            tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.GetResourceTagsResponseBody = GetResourceTagsResponseBody;
class GetResourceTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetResourceTagsResponseBody,
        };
    }
}
exports.GetResourceTagsResponse = GetResourceTagsResponse;
class GetServiceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetServiceHeaders = GetServiceHeaders;
class GetServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetServiceRequest = GetServiceRequest;
class GetServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            internetAccess: 'internetAccess',
            lastModifiedTime: 'lastModifiedTime',
            logConfig: 'logConfig',
            nasConfig: 'nasConfig',
            role: 'role',
            serviceId: 'serviceId',
            serviceName: 'serviceName',
            tracingConfig: 'tracingConfig',
            vpcConfig: 'vpcConfig',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            internetAccess: 'boolean',
            lastModifiedTime: 'string',
            logConfig: LogConfig,
            nasConfig: NASConfig,
            role: 'string',
            serviceId: 'string',
            serviceName: 'string',
            tracingConfig: TracingConfig,
            vpcConfig: VPCConfig,
        };
    }
}
exports.GetServiceResponseBody = GetServiceResponseBody;
class GetServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetServiceResponseBody,
        };
    }
}
exports.GetServiceResponse = GetServiceResponse;
class GetStatefulAsyncInvocationHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcCodeChecksum: 'X-Fc-Code-Checksum',
            xFcDate: 'X-Fc-Date',
            xFcInvocationType: 'X-Fc-Invocation-Type',
            xFcLogType: 'X-Fc-Log-Type',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcCodeChecksum: 'string',
            xFcDate: 'string',
            xFcInvocationType: 'string',
            xFcLogType: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetStatefulAsyncInvocationHeaders = GetStatefulAsyncInvocationHeaders;
class GetStatefulAsyncInvocationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.GetStatefulAsyncInvocationRequest = GetStatefulAsyncInvocationRequest;
class GetStatefulAsyncInvocationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StatefulAsyncInvocation,
        };
    }
}
exports.GetStatefulAsyncInvocationResponse = GetStatefulAsyncInvocationResponse;
class GetTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.GetTriggerHeaders = GetTriggerHeaders;
class GetTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            domainName: 'domainName',
            invocationRole: 'invocationRole',
            lastModifiedTime: 'lastModifiedTime',
            qualifier: 'qualifier',
            sourceArn: 'sourceArn',
            triggerConfig: 'triggerConfig',
            triggerId: 'triggerId',
            triggerName: 'triggerName',
            triggerType: 'triggerType',
            urlInternet: 'urlInternet',
            urlIntranet: 'urlIntranet',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            domainName: 'string',
            invocationRole: 'string',
            lastModifiedTime: 'string',
            qualifier: 'string',
            sourceArn: 'string',
            triggerConfig: 'string',
            triggerId: 'string',
            triggerName: 'string',
            triggerType: 'string',
            urlInternet: 'string',
            urlIntranet: 'string',
        };
    }
}
exports.GetTriggerResponseBody = GetTriggerResponseBody;
class GetTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTriggerResponseBody,
        };
    }
}
exports.GetTriggerResponse = GetTriggerResponse;
class InvokeFunctionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcInvocationType: 'X-Fc-Invocation-Type',
            xFcLogType: 'X-Fc-Log-Type',
            xFcStatefulAsyncInvocationId: 'X-Fc-Stateful-Async-Invocation-Id',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcInvocationType: 'string',
            xFcLogType: 'string',
            xFcStatefulAsyncInvocationId: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.InvokeFunctionHeaders = InvokeFunctionHeaders;
class InvokeFunctionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            body: 'Buffer',
            qualifier: 'string',
        };
    }
}
exports.InvokeFunctionRequest = InvokeFunctionRequest;
class InvokeFunctionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: 'Buffer',
        };
    }
}
exports.InvokeFunctionResponse = InvokeFunctionResponse;
class ListAliasesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListAliasesHeaders = ListAliasesHeaders;
class ListAliasesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            startKey: 'string',
        };
    }
}
exports.ListAliasesRequest = ListAliasesRequest;
class ListAliasesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliases: 'aliases',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            aliases: { 'type': 'array', 'itemType': ListAliasesResponseBodyAliases },
            nextToken: 'string',
        };
    }
}
exports.ListAliasesResponseBody = ListAliasesResponseBody;
class ListAliasesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAliasesResponseBody,
        };
    }
}
exports.ListAliasesResponse = ListAliasesResponse;
class ListCustomDomainsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListCustomDomainsHeaders = ListCustomDomainsHeaders;
class ListCustomDomainsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            startKey: 'string',
        };
    }
}
exports.ListCustomDomainsRequest = ListCustomDomainsRequest;
class ListCustomDomainsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customDomains: 'customDomains',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            customDomains: { 'type': 'array', 'itemType': ListCustomDomainsResponseBodyCustomDomains },
            nextToken: 'string',
        };
    }
}
exports.ListCustomDomainsResponseBody = ListCustomDomainsResponseBody;
class ListCustomDomainsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListCustomDomainsResponseBody,
        };
    }
}
exports.ListCustomDomainsResponse = ListCustomDomainsResponse;
class ListEventSourcesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListEventSourcesHeaders = ListEventSourcesHeaders;
class ListEventSourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.ListEventSourcesRequest = ListEventSourcesRequest;
class ListEventSourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventSources: 'eventSources',
        };
    }
    static types() {
        return {
            eventSources: { 'type': 'array', 'itemType': ListEventSourcesResponseBodyEventSources },
        };
    }
}
exports.ListEventSourcesResponseBody = ListEventSourcesResponseBody;
class ListEventSourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListEventSourcesResponseBody,
        };
    }
}
exports.ListEventSourcesResponse = ListEventSourcesResponse;
class ListFunctionAsyncInvokeConfigsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcCodeChecksum: 'X-Fc-Code-Checksum',
            xFcDate: 'X-Fc-Date',
            xFcInvocationType: 'X-Fc-Invocation-Type',
            xFcLogType: 'X-Fc-Log-Type',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcCodeChecksum: 'string',
            xFcDate: 'string',
            xFcInvocationType: 'string',
            xFcLogType: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListFunctionAsyncInvokeConfigsHeaders = ListFunctionAsyncInvokeConfigsHeaders;
class ListFunctionAsyncInvokeConfigsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
        };
    }
}
exports.ListFunctionAsyncInvokeConfigsRequest = ListFunctionAsyncInvokeConfigsRequest;
class ListFunctionAsyncInvokeConfigsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configs: 'configs',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            configs: { 'type': 'array', 'itemType': ListFunctionAsyncInvokeConfigsResponseBodyConfigs },
            nextToken: 'string',
        };
    }
}
exports.ListFunctionAsyncInvokeConfigsResponseBody = ListFunctionAsyncInvokeConfigsResponseBody;
class ListFunctionAsyncInvokeConfigsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListFunctionAsyncInvokeConfigsResponseBody,
        };
    }
}
exports.ListFunctionAsyncInvokeConfigsResponse = ListFunctionAsyncInvokeConfigsResponse;
class ListFunctionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListFunctionsHeaders = ListFunctionsHeaders;
class ListFunctionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            qualifier: 'qualifier',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            qualifier: 'string',
            startKey: 'string',
        };
    }
}
exports.ListFunctionsRequest = ListFunctionsRequest;
class ListFunctionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            functions: 'functions',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            functions: { 'type': 'array', 'itemType': ListFunctionsResponseBodyFunctions },
            nextToken: 'string',
        };
    }
}
exports.ListFunctionsResponseBody = ListFunctionsResponseBody;
class ListFunctionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListFunctionsResponseBody,
        };
    }
}
exports.ListFunctionsResponse = ListFunctionsResponse;
class ListInstancesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListInstancesHeaders = ListInstancesHeaders;
class ListInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceIds: 'instanceIds',
            limit: 'limit',
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            instanceIds: { 'type': 'array', 'itemType': 'string' },
            limit: 'number',
            qualifier: 'string',
        };
    }
}
exports.ListInstancesRequest = ListInstancesRequest;
class ListInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instances: 'instances',
        };
    }
    static types() {
        return {
            instances: { 'type': 'array', 'itemType': ListInstancesResponseBodyInstances },
        };
    }
}
exports.ListInstancesResponseBody = ListInstancesResponseBody;
class ListInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListInstancesResponseBody,
        };
    }
}
exports.ListInstancesResponse = ListInstancesResponse;
class ListLayerVersionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListLayerVersionsHeaders = ListLayerVersionsHeaders;
class ListLayerVersionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            startVersion: 'startVersion',
        };
    }
    static types() {
        return {
            limit: 'number',
            startVersion: 'number',
        };
    }
}
exports.ListLayerVersionsRequest = ListLayerVersionsRequest;
class ListLayerVersionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            layers: 'layers',
            nextVersion: 'nextVersion',
        };
    }
    static types() {
        return {
            layers: { 'type': 'array', 'itemType': Layer },
            nextVersion: 'number',
        };
    }
}
exports.ListLayerVersionsResponseBody = ListLayerVersionsResponseBody;
class ListLayerVersionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListLayerVersionsResponseBody,
        };
    }
}
exports.ListLayerVersionsResponse = ListLayerVersionsResponse;
class ListLayersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListLayersHeaders = ListLayersHeaders;
class ListLayersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            startKey: 'string',
        };
    }
}
exports.ListLayersRequest = ListLayersRequest;
class ListLayersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            layers: 'layers',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            layers: { 'type': 'array', 'itemType': Layer },
            nextToken: 'string',
        };
    }
}
exports.ListLayersResponseBody = ListLayersResponseBody;
class ListLayersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListLayersResponseBody,
        };
    }
}
exports.ListLayersResponse = ListLayersResponse;
class ListOnDemandConfigsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListOnDemandConfigsHeaders = ListOnDemandConfigsHeaders;
class ListOnDemandConfigsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            startKey: 'string',
        };
    }
}
exports.ListOnDemandConfigsRequest = ListOnDemandConfigsRequest;
class ListOnDemandConfigsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configs: 'configs',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            configs: { 'type': 'array', 'itemType': OnDemandConfig },
            nextToken: 'string',
        };
    }
}
exports.ListOnDemandConfigsResponseBody = ListOnDemandConfigsResponseBody;
class ListOnDemandConfigsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOnDemandConfigsResponseBody,
        };
    }
}
exports.ListOnDemandConfigsResponse = ListOnDemandConfigsResponse;
class ListProvisionConfigsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListProvisionConfigsHeaders = ListProvisionConfigsHeaders;
class ListProvisionConfigsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            qualifier: 'qualifier',
            serviceName: 'serviceName',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            qualifier: 'string',
            serviceName: 'string',
        };
    }
}
exports.ListProvisionConfigsRequest = ListProvisionConfigsRequest;
class ListProvisionConfigsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            provisionConfigs: 'provisionConfigs',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            provisionConfigs: { 'type': 'array', 'itemType': ListProvisionConfigsResponseBodyProvisionConfigs },
        };
    }
}
exports.ListProvisionConfigsResponseBody = ListProvisionConfigsResponseBody;
class ListProvisionConfigsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListProvisionConfigsResponseBody,
        };
    }
}
exports.ListProvisionConfigsResponse = ListProvisionConfigsResponse;
class ListReservedCapacitiesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListReservedCapacitiesHeaders = ListReservedCapacitiesHeaders;
class ListReservedCapacitiesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            limit: 'string',
            nextToken: 'string',
        };
    }
}
exports.ListReservedCapacitiesRequest = ListReservedCapacitiesRequest;
class ListReservedCapacitiesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            reservedCapacities: 'reservedCapacities',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            reservedCapacities: { 'type': 'array', 'itemType': OpenReservedCapacity },
        };
    }
}
exports.ListReservedCapacitiesResponseBody = ListReservedCapacitiesResponseBody;
class ListReservedCapacitiesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListReservedCapacitiesResponseBody,
        };
    }
}
exports.ListReservedCapacitiesResponse = ListReservedCapacitiesResponse;
class ListServiceVersionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListServiceVersionsHeaders = ListServiceVersionsHeaders;
class ListServiceVersionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            direction: 'direction',
            limit: 'limit',
            nextToken: 'nextToken',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            direction: 'string',
            limit: 'number',
            nextToken: 'string',
            startKey: 'string',
        };
    }
}
exports.ListServiceVersionsRequest = ListServiceVersionsRequest;
class ListServiceVersionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            direction: 'direction',
            nextToken: 'nextToken',
            versions: 'versions',
        };
    }
    static types() {
        return {
            direction: 'string',
            nextToken: 'string',
            versions: { 'type': 'array', 'itemType': ListServiceVersionsResponseBodyVersions },
        };
    }
}
exports.ListServiceVersionsResponseBody = ListServiceVersionsResponseBody;
class ListServiceVersionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListServiceVersionsResponseBody,
        };
    }
}
exports.ListServiceVersionsResponse = ListServiceVersionsResponse;
class ListServicesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListServicesHeaders = ListServicesHeaders;
class ListServicesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            startKey: 'string',
        };
    }
}
exports.ListServicesRequest = ListServicesRequest;
class ListServicesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            services: 'services',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            services: { 'type': 'array', 'itemType': ListServicesResponseBodyServices },
        };
    }
}
exports.ListServicesResponseBody = ListServicesResponseBody;
class ListServicesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListServicesResponseBody,
        };
    }
}
exports.ListServicesResponse = ListServicesResponse;
class ListStatefulAsyncInvocationFunctionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListStatefulAsyncInvocationFunctionsHeaders = ListStatefulAsyncInvocationFunctionsHeaders;
class ListStatefulAsyncInvocationFunctionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
        };
    }
}
exports.ListStatefulAsyncInvocationFunctionsRequest = ListStatefulAsyncInvocationFunctionsRequest;
class ListStatefulAsyncInvocationFunctionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': AsyncConfigMeta },
            nextToken: 'string',
        };
    }
}
exports.ListStatefulAsyncInvocationFunctionsResponseBody = ListStatefulAsyncInvocationFunctionsResponseBody;
class ListStatefulAsyncInvocationFunctionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListStatefulAsyncInvocationFunctionsResponseBody,
        };
    }
}
exports.ListStatefulAsyncInvocationFunctionsResponse = ListStatefulAsyncInvocationFunctionsResponse;
class ListStatefulAsyncInvocationsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcCodeChecksum: 'X-Fc-Code-Checksum',
            xFcDate: 'X-Fc-Date',
            xFcInvocationType: 'X-Fc-Invocation-Type',
            xFcLogType: 'X-Fc-Log-Type',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcCodeChecksum: 'string',
            xFcDate: 'string',
            xFcInvocationType: 'string',
            xFcLogType: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListStatefulAsyncInvocationsHeaders = ListStatefulAsyncInvocationsHeaders;
class ListStatefulAsyncInvocationsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            includePayload: 'includePayload',
            invocationIdPrefix: 'invocationIdPrefix',
            limit: 'limit',
            nextToken: 'nextToken',
            qualifier: 'qualifier',
            sortOrderByTime: 'sortOrderByTime',
            startedTimeBegin: 'startedTimeBegin',
            startedTimeEnd: 'startedTimeEnd',
            status: 'status',
        };
    }
    static types() {
        return {
            includePayload: 'boolean',
            invocationIdPrefix: 'string',
            limit: 'number',
            nextToken: 'string',
            qualifier: 'string',
            sortOrderByTime: 'string',
            startedTimeBegin: 'number',
            startedTimeEnd: 'number',
            status: 'string',
        };
    }
}
exports.ListStatefulAsyncInvocationsRequest = ListStatefulAsyncInvocationsRequest;
class ListStatefulAsyncInvocationsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invocations: 'invocations',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            invocations: { 'type': 'array', 'itemType': StatefulAsyncInvocation },
            nextToken: 'string',
        };
    }
}
exports.ListStatefulAsyncInvocationsResponseBody = ListStatefulAsyncInvocationsResponseBody;
class ListStatefulAsyncInvocationsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListStatefulAsyncInvocationsResponseBody,
        };
    }
}
exports.ListStatefulAsyncInvocationsResponse = ListStatefulAsyncInvocationsResponse;
class ListTaggedResourcesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListTaggedResourcesHeaders = ListTaggedResourcesHeaders;
class ListTaggedResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
        };
    }
}
exports.ListTaggedResourcesRequest = ListTaggedResourcesRequest;
class ListTaggedResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            resources: 'resources',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            resources: { 'type': 'array', 'itemType': Resource },
        };
    }
}
exports.ListTaggedResourcesResponseBody = ListTaggedResourcesResponseBody;
class ListTaggedResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTaggedResourcesResponseBody,
        };
    }
}
exports.ListTaggedResourcesResponse = ListTaggedResourcesResponse;
class ListTriggersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListTriggersHeaders = ListTriggersHeaders;
class ListTriggersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            limit: 'limit',
            nextToken: 'nextToken',
            prefix: 'prefix',
            startKey: 'startKey',
        };
    }
    static types() {
        return {
            limit: 'number',
            nextToken: 'string',
            prefix: 'string',
            startKey: 'string',
        };
    }
}
exports.ListTriggersRequest = ListTriggersRequest;
class ListTriggersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            triggers: 'triggers',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            triggers: { 'type': 'array', 'itemType': ListTriggersResponseBodyTriggers },
        };
    }
}
exports.ListTriggersResponseBody = ListTriggersResponseBody;
class ListTriggersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTriggersResponseBody,
        };
    }
}
exports.ListTriggersResponse = ListTriggersResponse;
class ListVpcBindingsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.ListVpcBindingsHeaders = ListVpcBindingsHeaders;
class ListVpcBindingsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            vpcIds: 'vpcIds',
        };
    }
    static types() {
        return {
            vpcIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ListVpcBindingsResponseBody = ListVpcBindingsResponseBody;
class ListVpcBindingsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListVpcBindingsResponseBody,
        };
    }
}
exports.ListVpcBindingsResponse = ListVpcBindingsResponse;
class PublishServiceVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.PublishServiceVersionHeaders = PublishServiceVersionHeaders;
class PublishServiceVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
        };
    }
    static types() {
        return {
            description: 'string',
        };
    }
}
exports.PublishServiceVersionRequest = PublishServiceVersionRequest;
class PublishServiceVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            lastModifiedTime: 'lastModifiedTime',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            lastModifiedTime: 'string',
            versionId: 'string',
        };
    }
}
exports.PublishServiceVersionResponseBody = PublishServiceVersionResponseBody;
class PublishServiceVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PublishServiceVersionResponseBody,
        };
    }
}
exports.PublishServiceVersionResponse = PublishServiceVersionResponse;
class PutFunctionAsyncInvokeConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.PutFunctionAsyncInvokeConfigHeaders = PutFunctionAsyncInvokeConfigHeaders;
class PutFunctionAsyncInvokeConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            destinationConfig: 'destinationConfig',
            maxAsyncEventAgeInSeconds: 'maxAsyncEventAgeInSeconds',
            maxAsyncRetryAttempts: 'maxAsyncRetryAttempts',
            statefulInvocation: 'statefulInvocation',
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            destinationConfig: DestinationConfig,
            maxAsyncEventAgeInSeconds: 'number',
            maxAsyncRetryAttempts: 'number',
            statefulInvocation: 'boolean',
            qualifier: 'string',
        };
    }
}
exports.PutFunctionAsyncInvokeConfigRequest = PutFunctionAsyncInvokeConfigRequest;
class PutFunctionAsyncInvokeConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            destinationConfig: 'destinationConfig',
            function: 'function',
            lastModifiedTime: 'lastModifiedTime',
            maxAsyncEventAgeInSeconds: 'maxAsyncEventAgeInSeconds',
            maxAsyncRetryAttempts: 'maxAsyncRetryAttempts',
            qualifier: 'qualifier',
            service: 'service',
            statefulInvocation: 'statefulInvocation',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            destinationConfig: DestinationConfig,
            function: 'string',
            lastModifiedTime: 'string',
            maxAsyncEventAgeInSeconds: 'number',
            maxAsyncRetryAttempts: 'number',
            qualifier: 'string',
            service: 'string',
            statefulInvocation: 'boolean',
        };
    }
}
exports.PutFunctionAsyncInvokeConfigResponseBody = PutFunctionAsyncInvokeConfigResponseBody;
class PutFunctionAsyncInvokeConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PutFunctionAsyncInvokeConfigResponseBody,
        };
    }
}
exports.PutFunctionAsyncInvokeConfigResponse = PutFunctionAsyncInvokeConfigResponse;
class PutFunctionOnDemandConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.PutFunctionOnDemandConfigHeaders = PutFunctionOnDemandConfigHeaders;
class PutFunctionOnDemandConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maximumInstanceCount: 'maximumInstanceCount',
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            maximumInstanceCount: 'number',
            qualifier: 'string',
        };
    }
}
exports.PutFunctionOnDemandConfigRequest = PutFunctionOnDemandConfigRequest;
class PutFunctionOnDemandConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maximumInstanceCount: 'maximumInstanceCount',
            resource: 'resource',
        };
    }
    static types() {
        return {
            maximumInstanceCount: 'number',
            resource: 'string',
        };
    }
}
exports.PutFunctionOnDemandConfigResponseBody = PutFunctionOnDemandConfigResponseBody;
class PutFunctionOnDemandConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PutFunctionOnDemandConfigResponseBody,
        };
    }
}
exports.PutFunctionOnDemandConfigResponse = PutFunctionOnDemandConfigResponse;
class PutProvisionConfigHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.PutProvisionConfigHeaders = PutProvisionConfigHeaders;
class PutProvisionConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alwaysAllocateCPU: 'alwaysAllocateCPU',
            scheduledActions: 'scheduledActions',
            target: 'target',
            targetTrackingPolicies: 'targetTrackingPolicies',
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            alwaysAllocateCPU: 'boolean',
            scheduledActions: { 'type': 'array', 'itemType': ScheduledActions },
            target: 'number',
            targetTrackingPolicies: { 'type': 'array', 'itemType': TargetTrackingPolicies },
            qualifier: 'string',
        };
    }
}
exports.PutProvisionConfigRequest = PutProvisionConfigRequest;
class PutProvisionConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alwaysAllocateCPU: 'alwaysAllocateCPU',
            current: 'current',
            resource: 'resource',
            scheduledActions: 'scheduledActions',
            target: 'target',
            targetTrackingPolicies: 'targetTrackingPolicies',
        };
    }
    static types() {
        return {
            alwaysAllocateCPU: 'boolean',
            current: 'number',
            resource: 'string',
            scheduledActions: { 'type': 'array', 'itemType': ScheduledActions },
            target: 'number',
            targetTrackingPolicies: { 'type': 'array', 'itemType': TargetTrackingPolicies },
        };
    }
}
exports.PutProvisionConfigResponseBody = PutProvisionConfigResponseBody;
class PutProvisionConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PutProvisionConfigResponseBody,
        };
    }
}
exports.PutProvisionConfigResponse = PutProvisionConfigResponse;
class RegisterEventSourceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.RegisterEventSourceHeaders = RegisterEventSourceHeaders;
class RegisterEventSourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            sourceArn: 'sourceArn',
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            sourceArn: 'string',
            qualifier: 'string',
        };
    }
}
exports.RegisterEventSourceRequest = RegisterEventSourceRequest;
class RegisterEventSourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            sourceArn: 'sourceArn',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            sourceArn: 'string',
        };
    }
}
exports.RegisterEventSourceResponseBody = RegisterEventSourceResponseBody;
class RegisterEventSourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RegisterEventSourceResponseBody,
        };
    }
}
exports.RegisterEventSourceResponse = RegisterEventSourceResponse;
class StopStatefulAsyncInvocationHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.StopStatefulAsyncInvocationHeaders = StopStatefulAsyncInvocationHeaders;
class StopStatefulAsyncInvocationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            qualifier: 'qualifier',
        };
    }
    static types() {
        return {
            qualifier: 'string',
        };
    }
}
exports.StopStatefulAsyncInvocationRequest = StopStatefulAsyncInvocationRequest;
class StopStatefulAsyncInvocationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.StopStatefulAsyncInvocationResponse = StopStatefulAsyncInvocationResponse;
class TagResourceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.TagResourceHeaders = TagResourceHeaders;
class TagResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceArn: 'resourceArn',
            tags: 'tags',
        };
    }
    static types() {
        return {
            resourceArn: 'string',
            tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.TagResourceRequest = TagResourceRequest;
class TagResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.TagResourceResponse = TagResourceResponse;
class UntagResourceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.UntagResourceHeaders = UntagResourceHeaders;
class UntagResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            all: 'all',
            resourceArn: 'resourceArn',
            tagKeys: 'tagKeys',
        };
    }
    static types() {
        return {
            all: 'boolean',
            resourceArn: 'string',
            tagKeys: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UntagResourceRequest = UntagResourceRequest;
class UntagResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UntagResourceResponse = UntagResourceResponse;
class UpdateAliasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.UpdateAliasHeaders = UpdateAliasHeaders;
class UpdateAliasRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalVersionWeight: 'additionalVersionWeight',
            description: 'description',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
            description: 'string',
            versionId: 'string',
        };
    }
}
exports.UpdateAliasRequest = UpdateAliasRequest;
class UpdateAliasResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalVersionWeight: 'additionalVersionWeight',
            aliasName: 'aliasName',
            createdTime: 'createdTime',
            description: 'description',
            lastModifiedTime: 'lastModifiedTime',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
            aliasName: 'string',
            createdTime: 'string',
            description: 'string',
            lastModifiedTime: 'string',
            versionId: 'string',
        };
    }
}
exports.UpdateAliasResponseBody = UpdateAliasResponseBody;
class UpdateAliasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateAliasResponseBody,
        };
    }
}
exports.UpdateAliasResponse = UpdateAliasResponse;
class UpdateCustomDomainHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.UpdateCustomDomainHeaders = UpdateCustomDomainHeaders;
class UpdateCustomDomainRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certConfig: 'certConfig',
            protocol: 'protocol',
            routeConfig: 'routeConfig',
            tlsConfig: 'tlsConfig',
        };
    }
    static types() {
        return {
            certConfig: CertConfig,
            protocol: 'string',
            routeConfig: RouteConfig,
            tlsConfig: TLSConfig,
        };
    }
}
exports.UpdateCustomDomainRequest = UpdateCustomDomainRequest;
class UpdateCustomDomainResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            apiVersion: 'apiVersion',
            certConfig: 'certConfig',
            createdTime: 'createdTime',
            domainName: 'domainName',
            lastModifiedTime: 'lastModifiedTime',
            protocol: 'protocol',
            routeConfig: 'routeConfig',
            tlsConfig: 'tlsConfig',
        };
    }
    static types() {
        return {
            accountId: 'string',
            apiVersion: 'string',
            certConfig: CertConfig,
            createdTime: 'string',
            domainName: 'string',
            lastModifiedTime: 'string',
            protocol: 'string',
            routeConfig: RouteConfig,
            tlsConfig: TLSConfig,
        };
    }
}
exports.UpdateCustomDomainResponseBody = UpdateCustomDomainResponseBody;
class UpdateCustomDomainResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateCustomDomainResponseBody,
        };
    }
}
exports.UpdateCustomDomainResponse = UpdateCustomDomainResponse;
class UpdateFunctionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcCodeChecksum: 'X-Fc-Code-Checksum',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcCodeChecksum: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.UpdateFunctionHeaders = UpdateFunctionHeaders;
class UpdateFunctionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceConcurrency: 'InstanceConcurrency',
            caPort: 'caPort',
            code: 'code',
            customContainerConfig: 'customContainerConfig',
            customDNS: 'customDNS',
            customRuntimeConfig: 'customRuntimeConfig',
            description: 'description',
            environmentVariables: 'environmentVariables',
            handler: 'handler',
            initializationTimeout: 'initializationTimeout',
            initializer: 'initializer',
            instanceLifecycleConfig: 'instanceLifecycleConfig',
            instanceSoftConcurrency: 'instanceSoftConcurrency',
            instanceType: 'instanceType',
            layers: 'layers',
            memorySize: 'memorySize',
            runtime: 'runtime',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            instanceConcurrency: 'number',
            caPort: 'number',
            code: Code,
            customContainerConfig: CustomContainerConfig,
            customDNS: CustomDNS,
            customRuntimeConfig: CustomRuntimeConfig,
            description: 'string',
            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            handler: 'string',
            initializationTimeout: 'number',
            initializer: 'string',
            instanceLifecycleConfig: InstanceLifecycleConfig,
            instanceSoftConcurrency: 'number',
            instanceType: 'string',
            layers: { 'type': 'array', 'itemType': 'string' },
            memorySize: 'number',
            runtime: 'string',
            timeout: 'number',
        };
    }
}
exports.UpdateFunctionRequest = UpdateFunctionRequest;
class UpdateFunctionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            caPort: 'caPort',
            codeChecksum: 'codeChecksum',
            codeSize: 'codeSize',
            createdTime: 'createdTime',
            customContainerConfig: 'customContainerConfig',
            customDNS: 'customDNS',
            customRuntimeConfig: 'customRuntimeConfig',
            description: 'description',
            environmentVariables: 'environmentVariables',
            functionId: 'functionId',
            functionName: 'functionName',
            handler: 'handler',
            initializationTimeout: 'initializationTimeout',
            initializer: 'initializer',
            instanceLifecycleConfig: 'instanceLifecycleConfig',
            instanceSoftConcurrency: 'instanceSoftConcurrency',
            instanceType: 'instanceType',
            lastModifiedTime: 'lastModifiedTime',
            layers: 'layers',
            memorySize: 'memorySize',
            runtime: 'runtime',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            caPort: 'number',
            codeChecksum: 'string',
            codeSize: 'number',
            createdTime: 'string',
            customContainerConfig: CustomContainerConfig,
            customDNS: CustomDNS,
            customRuntimeConfig: CustomRuntimeConfig,
            description: 'string',
            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            functionId: 'string',
            functionName: 'string',
            handler: 'string',
            initializationTimeout: 'number',
            initializer: 'string',
            instanceLifecycleConfig: InstanceLifecycleConfig,
            instanceSoftConcurrency: 'number',
            instanceType: 'string',
            lastModifiedTime: 'string',
            layers: { 'type': 'array', 'itemType': 'string' },
            memorySize: 'number',
            runtime: 'string',
            timeout: 'number',
        };
    }
}
exports.UpdateFunctionResponseBody = UpdateFunctionResponseBody;
class UpdateFunctionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateFunctionResponseBody,
        };
    }
}
exports.UpdateFunctionResponse = UpdateFunctionResponse;
class UpdateServiceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.UpdateServiceHeaders = UpdateServiceHeaders;
class UpdateServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            internetAccess: 'internetAccess',
            logConfig: 'logConfig',
            nasConfig: 'nasConfig',
            role: 'role',
            tracingConfig: 'tracingConfig',
            vpcConfig: 'vpcConfig',
        };
    }
    static types() {
        return {
            description: 'string',
            internetAccess: 'boolean',
            logConfig: LogConfig,
            nasConfig: NASConfig,
            role: 'string',
            tracingConfig: TracingConfig,
            vpcConfig: VPCConfig,
        };
    }
}
exports.UpdateServiceRequest = UpdateServiceRequest;
class UpdateServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            internetAccess: 'internetAccess',
            lastModifiedTime: 'lastModifiedTime',
            logConfig: 'logConfig',
            nasConfig: 'nasConfig',
            role: 'role',
            serviceId: 'serviceId',
            serviceName: 'serviceName',
            tracingConfig: 'tracingConfig',
            vendorConfig: 'vendorConfig',
            vpcConfig: 'vpcConfig',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            internetAccess: 'boolean',
            lastModifiedTime: 'string',
            logConfig: LogConfig,
            nasConfig: NASConfig,
            role: 'string',
            serviceId: 'string',
            serviceName: 'string',
            tracingConfig: TracingConfig,
            vendorConfig: VendorConfig,
            vpcConfig: VPCConfig,
        };
    }
}
exports.UpdateServiceResponseBody = UpdateServiceResponseBody;
class UpdateServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateServiceResponseBody,
        };
    }
}
exports.UpdateServiceResponse = UpdateServiceResponse;
class UpdateTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            ifMatch: 'If-Match',
            xFcAccountId: 'X-Fc-Account-Id',
            xFcDate: 'X-Fc-Date',
            xFcTraceId: 'X-Fc-Trace-Id',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            ifMatch: 'string',
            xFcAccountId: 'string',
            xFcDate: 'string',
            xFcTraceId: 'string',
        };
    }
}
exports.UpdateTriggerHeaders = UpdateTriggerHeaders;
class UpdateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            invocationRole: 'invocationRole',
            qualifier: 'qualifier',
            triggerConfig: 'triggerConfig',
        };
    }
    static types() {
        return {
            description: 'string',
            invocationRole: 'string',
            qualifier: 'string',
            triggerConfig: 'string',
        };
    }
}
exports.UpdateTriggerRequest = UpdateTriggerRequest;
class UpdateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            domainName: 'domainName',
            invocationRole: 'invocationRole',
            lastModifiedTime: 'lastModifiedTime',
            qualifier: 'qualifier',
            sourceArn: 'sourceArn',
            triggerConfig: 'triggerConfig',
            triggerId: 'triggerId',
            triggerName: 'triggerName',
            triggerType: 'triggerType',
            urlInternet: 'urlInternet',
            urlIntranet: 'urlIntranet',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            domainName: 'string',
            invocationRole: 'string',
            lastModifiedTime: 'string',
            qualifier: 'string',
            sourceArn: 'string',
            triggerConfig: 'string',
            triggerId: 'string',
            triggerName: 'string',
            triggerType: 'string',
            urlInternet: 'string',
            urlIntranet: 'string',
        };
    }
}
exports.UpdateTriggerResponseBody = UpdateTriggerResponseBody;
class UpdateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateTriggerResponseBody,
        };
    }
}
exports.UpdateTriggerResponse = UpdateTriggerResponse;
class NASConfigMountPoints extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mountDir: 'mountDir',
            serverAddr: 'serverAddr',
        };
    }
    static types() {
        return {
            mountDir: 'string',
            serverAddr: 'string',
        };
    }
}
exports.NASConfigMountPoints = NASConfigMountPoints;
class ListAliasesResponseBodyAliases extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            additionalVersionWeight: 'additionalVersionWeight',
            aliasName: 'aliasName',
            createdTime: 'createdTime',
            description: 'description',
            lastModifiedTime: 'lastModifiedTime',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            additionalVersionWeight: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
            aliasName: 'string',
            createdTime: 'string',
            description: 'string',
            lastModifiedTime: 'string',
            versionId: 'string',
        };
    }
}
exports.ListAliasesResponseBodyAliases = ListAliasesResponseBodyAliases;
class ListCustomDomainsResponseBodyCustomDomains extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            apiVersion: 'apiVersion',
            certConfig: 'certConfig',
            createdTime: 'createdTime',
            domainName: 'domainName',
            lastModifiedTime: 'lastModifiedTime',
            protocol: 'protocol',
            routeConfig: 'routeConfig',
            tlsConfig: 'tlsConfig',
        };
    }
    static types() {
        return {
            accountId: 'string',
            apiVersion: 'string',
            certConfig: CertConfig,
            createdTime: 'string',
            domainName: 'string',
            lastModifiedTime: 'string',
            protocol: 'string',
            routeConfig: RouteConfig,
            tlsConfig: TLSConfig,
        };
    }
}
exports.ListCustomDomainsResponseBodyCustomDomains = ListCustomDomainsResponseBodyCustomDomains;
class ListEventSourcesResponseBodyEventSources extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            sourceArn: 'sourceArn',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            sourceArn: 'string',
        };
    }
}
exports.ListEventSourcesResponseBodyEventSources = ListEventSourcesResponseBodyEventSources;
class ListFunctionAsyncInvokeConfigsResponseBodyConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            destinationConfig: 'destinationConfig',
            function: 'function',
            lastModifiedTime: 'lastModifiedTime',
            maxAsyncEventAgeInSeconds: 'maxAsyncEventAgeInSeconds',
            maxAsyncRetryAttempts: 'maxAsyncRetryAttempts',
            qualifier: 'qualifier',
            service: 'service',
            statefulInvocation: 'statefulInvocation',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            destinationConfig: DestinationConfig,
            function: 'string',
            lastModifiedTime: 'string',
            maxAsyncEventAgeInSeconds: 'number',
            maxAsyncRetryAttempts: 'number',
            qualifier: 'string',
            service: 'string',
            statefulInvocation: 'boolean',
        };
    }
}
exports.ListFunctionAsyncInvokeConfigsResponseBodyConfigs = ListFunctionAsyncInvokeConfigsResponseBodyConfigs;
class ListFunctionsResponseBodyFunctions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            caPort: 'caPort',
            codeChecksum: 'codeChecksum',
            codeSize: 'codeSize',
            createdTime: 'createdTime',
            customContainerConfig: 'customContainerConfig',
            description: 'description',
            environmentVariables: 'environmentVariables',
            functionId: 'functionId',
            functionName: 'functionName',
            handler: 'handler',
            initializationTimeout: 'initializationTimeout',
            initializer: 'initializer',
            instanceConcurrency: 'instanceConcurrency',
            instanceLifecycleConfig: 'instanceLifecycleConfig',
            instanceSoftConcurrency: 'instanceSoftConcurrency',
            instanceType: 'instanceType',
            lastModifiedTime: 'lastModifiedTime',
            layers: 'layers',
            memorySize: 'memorySize',
            runtime: 'runtime',
            timeout: 'timeout',
        };
    }
    static types() {
        return {
            caPort: 'number',
            codeChecksum: 'string',
            codeSize: 'number',
            createdTime: 'string',
            customContainerConfig: CustomContainerConfig,
            description: 'string',
            environmentVariables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            functionId: 'string',
            functionName: 'string',
            handler: 'string',
            initializationTimeout: 'number',
            initializer: 'string',
            instanceConcurrency: 'number',
            instanceLifecycleConfig: InstanceLifecycleConfig,
            instanceSoftConcurrency: 'number',
            instanceType: 'string',
            lastModifiedTime: 'string',
            layers: { 'type': 'array', 'itemType': 'string' },
            memorySize: 'number',
            runtime: 'string',
            timeout: 'number',
        };
    }
}
exports.ListFunctionsResponseBodyFunctions = ListFunctionsResponseBodyFunctions;
class ListInstancesResponseBodyInstances extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instanceId',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            versionId: 'string',
        };
    }
}
exports.ListInstancesResponseBodyInstances = ListInstancesResponseBodyInstances;
class ListProvisionConfigsResponseBodyProvisionConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alwaysAllocateCPU: 'alwaysAllocateCPU',
            current: 'current',
            currentError: 'currentError',
            resource: 'resource',
            scheduledActions: 'scheduledActions',
            target: 'target',
            targetTrackingPolicies: 'targetTrackingPolicies',
        };
    }
    static types() {
        return {
            alwaysAllocateCPU: 'boolean',
            current: 'number',
            currentError: 'string',
            resource: 'string',
            scheduledActions: { 'type': 'array', 'itemType': ScheduledActions },
            target: 'number',
            targetTrackingPolicies: { 'type': 'array', 'itemType': TargetTrackingPolicies },
        };
    }
}
exports.ListProvisionConfigsResponseBodyProvisionConfigs = ListProvisionConfigsResponseBodyProvisionConfigs;
class ListServiceVersionsResponseBodyVersions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            lastModifiedTime: 'lastModifiedTime',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            lastModifiedTime: 'string',
            versionId: 'string',
        };
    }
}
exports.ListServiceVersionsResponseBodyVersions = ListServiceVersionsResponseBodyVersions;
class ListServicesResponseBodyServices extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            internetAccess: 'internetAccess',
            lastModifiedTime: 'lastModifiedTime',
            logConfig: 'logConfig',
            nasConfig: 'nasConfig',
            role: 'role',
            serviceId: 'serviceId',
            serviceName: 'serviceName',
            tracingConfig: 'tracingConfig',
            vpcConfig: 'vpcConfig',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            internetAccess: 'boolean',
            lastModifiedTime: 'string',
            logConfig: LogConfig,
            nasConfig: NASConfig,
            role: 'string',
            serviceId: 'string',
            serviceName: 'string',
            tracingConfig: TracingConfig,
            vpcConfig: VPCConfig,
        };
    }
}
exports.ListServicesResponseBodyServices = ListServicesResponseBodyServices;
class ListTriggersResponseBodyTriggers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createdTime: 'createdTime',
            description: 'description',
            domainName: 'domainName',
            invocationRole: 'invocationRole',
            lastModifiedTime: 'lastModifiedTime',
            qualifier: 'qualifier',
            sourceArn: 'sourceArn',
            triggerConfig: 'triggerConfig',
            triggerId: 'triggerId',
            triggerName: 'triggerName',
            triggerType: 'triggerType',
            urlInternet: 'urlInternet',
            urlIntranet: 'urlIntranet',
        };
    }
    static types() {
        return {
            createdTime: 'string',
            description: 'string',
            domainName: 'string',
            invocationRole: 'string',
            lastModifiedTime: 'string',
            qualifier: 'string',
            sourceArn: 'string',
            triggerConfig: 'string',
            triggerId: 'string',
            triggerName: 'string',
            triggerType: 'string',
            urlInternet: 'string',
            urlIntranet: 'string',
        };
    }
}
exports.ListTriggersResponseBodyTriggers = ListTriggersResponseBodyTriggers;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "regional";
        this._endpointMap = {
            'ap-northeast-1': "account-id.ap-northeast-1.fc.aliyuncs.com",
            'ap-south-1': "account-id.ap-south-1.fc.aliyuncs.com",
            'ap-southeast-1': "account-id.ap-southeast-1.fc.aliyuncs.com",
            'ap-southeast-2': "account-id.ap-southeast-2.fc.aliyuncs.com",
            'ap-southeast-3': "account-id.ap-southeast-3.fc.aliyuncs.com",
            'ap-southeast-5': "account-id.ap-southeast-5.fc.aliyuncs.com",
            'cn-beijing': "account-id.cn-beijing.fc.aliyuncs.com",
            'cn-chengdu': "account-id.cn-chengdu.fc.aliyuncs.com",
            'cn-hangzhou': "account-id.cn-hangzhou.fc.aliyuncs.com",
            'cn-hangzhou-finance': "account-id.cn-hangzhou-finance.fc.aliyuncs.com",
            'cn-hongkong': "account-id.cn-hongkong.fc.aliyuncs.com",
            'cn-huhehaote': "account-id.cn-huhehaote.fc.aliyuncs.com",
            'cn-north-2-gov-1': "account-id.cn-north-2-gov-1.fc.aliyuncs.com",
            'cn-qingdao': "account-id.cn-qingdao.fc.aliyuncs.com",
            'cn-shanghai': "account-id.cn-shanghai.fc.aliyuncs.com",
            'cn-shenzhen': "account-id.cn-shenzhen.fc.aliyuncs.com",
            'cn-zhangjiakou': "account-id.cn-zhangjiakou.fc.aliyuncs.com",
            'eu-central-1': "account-id.eu-central-1.fc.aliyuncs.com",
            'eu-west-1': "account-id.eu-west-1.fc.aliyuncs.com",
            'us-east-1': "account-id.us-east-1.fc.aliyuncs.com",
            'us-west-1': "account-id.us-west-1.fc.aliyuncs.com",
        };
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("fc-open", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    async createAlias(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateAliasHeaders({});
        return await this.createAliasWithOptions(serviceName, request, headers, runtime);
    }
    async createAliasWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.additionalVersionWeight)) {
            body["additionalVersionWeight"] = request.additionalVersionWeight;
        }
        if (!tea_util_1.default.isUnset(request.aliasName)) {
            body["aliasName"] = request.aliasName;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.versionId)) {
            body["versionId"] = request.versionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAlias",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/aliases`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateAliasResponse({}));
    }
    async createCustomDomain(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateCustomDomainHeaders({});
        return await this.createCustomDomainWithOptions(request, headers, runtime);
    }
    async createCustomDomainWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.certConfig))) {
            body["certConfig"] = request.certConfig;
        }
        if (!tea_util_1.default.isUnset(request.domainName)) {
            body["domainName"] = request.domainName;
        }
        if (!tea_util_1.default.isUnset(request.protocol)) {
            body["protocol"] = request.protocol;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.routeConfig))) {
            body["routeConfig"] = request.routeConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.tlsConfig))) {
            body["tlsConfig"] = request.tlsConfig;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateCustomDomain",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/custom-domains`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateCustomDomainResponse({}));
    }
    async createFunction(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateFunctionHeaders({});
        return await this.createFunctionWithOptions(serviceName, request, headers, runtime);
    }
    async createFunctionWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.caPort)) {
            body["caPort"] = request.caPort;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.code))) {
            body["code"] = request.code;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.customContainerConfig))) {
            body["customContainerConfig"] = request.customContainerConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.customDNS))) {
            body["customDNS"] = request.customDNS;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.customRuntimeConfig))) {
            body["customRuntimeConfig"] = request.customRuntimeConfig;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.environmentVariables)) {
            body["environmentVariables"] = request.environmentVariables;
        }
        if (!tea_util_1.default.isUnset(request.functionName)) {
            body["functionName"] = request.functionName;
        }
        if (!tea_util_1.default.isUnset(request.handler)) {
            body["handler"] = request.handler;
        }
        if (!tea_util_1.default.isUnset(request.initializationTimeout)) {
            body["initializationTimeout"] = request.initializationTimeout;
        }
        if (!tea_util_1.default.isUnset(request.initializer)) {
            body["initializer"] = request.initializer;
        }
        if (!tea_util_1.default.isUnset(request.instanceConcurrency)) {
            body["instanceConcurrency"] = request.instanceConcurrency;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.instanceLifecycleConfig))) {
            body["instanceLifecycleConfig"] = request.instanceLifecycleConfig;
        }
        if (!tea_util_1.default.isUnset(request.instanceSoftConcurrency)) {
            body["instanceSoftConcurrency"] = request.instanceSoftConcurrency;
        }
        if (!tea_util_1.default.isUnset(request.instanceType)) {
            body["instanceType"] = request.instanceType;
        }
        if (!tea_util_1.default.isUnset(request.layers)) {
            body["layers"] = request.layers;
        }
        if (!tea_util_1.default.isUnset(request.memorySize)) {
            body["memorySize"] = request.memorySize;
        }
        if (!tea_util_1.default.isUnset(request.runtime)) {
            body["runtime"] = request.runtime;
        }
        if (!tea_util_1.default.isUnset(request.timeout)) {
            body["timeout"] = request.timeout;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcCodeChecksum)) {
            realHeaders["X-Fc-Code-Checksum"] = tea_util_1.default.toJSONString(headers.xFcCodeChecksum);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateFunction",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateFunctionResponse({}));
    }
    async createLayerVersion(layerName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateLayerVersionHeaders({});
        return await this.createLayerVersionWithOptions(layerName, request, headers, runtime);
    }
    async createLayerVersionWithOptions(layerName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        layerName = openapi_util_1.default.getEncodeParam(layerName);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.code))) {
            body["Code"] = request.code;
        }
        if (!tea_util_1.default.isUnset(request.compatibleRuntime)) {
            body["compatibleRuntime"] = request.compatibleRuntime;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateLayerVersion",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/layers/${layerName}/versions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateLayerVersionResponse({}));
    }
    async createService(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateServiceHeaders({});
        return await this.createServiceWithOptions(request, headers, runtime);
    }
    async createServiceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.internetAccess)) {
            body["internetAccess"] = request.internetAccess;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.logConfig))) {
            body["logConfig"] = request.logConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.nasConfig))) {
            body["nasConfig"] = request.nasConfig;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset(request.serviceName)) {
            body["serviceName"] = request.serviceName;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.tracingConfig))) {
            body["tracingConfig"] = request.tracingConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.vpcConfig))) {
            body["vpcConfig"] = request.vpcConfig;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateService",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateServiceResponse({}));
    }
    async createTrigger(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTriggerHeaders({});
        return await this.createTriggerWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async createTriggerWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.invocationRole)) {
            body["invocationRole"] = request.invocationRole;
        }
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            body["qualifier"] = request.qualifier;
        }
        if (!tea_util_1.default.isUnset(request.sourceArn)) {
            body["sourceArn"] = request.sourceArn;
        }
        if (!tea_util_1.default.isUnset(request.triggerConfig)) {
            body["triggerConfig"] = request.triggerConfig;
        }
        if (!tea_util_1.default.isUnset(request.triggerName)) {
            body["triggerName"] = request.triggerName;
        }
        if (!tea_util_1.default.isUnset(request.triggerType)) {
            body["triggerType"] = request.triggerType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTrigger",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateTriggerResponse({}));
    }
    async createVpcBinding(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateVpcBindingHeaders({});
        return await this.createVpcBindingWithOptions(serviceName, request, headers, runtime);
    }
    async createVpcBindingWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.vpcId)) {
            body["vpcId"] = request.vpcId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateVpcBinding",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/bindings`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateVpcBindingResponse({}));
    }
    async deleteAlias(serviceName, aliasName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteAliasHeaders({});
        return await this.deleteAliasWithOptions(serviceName, aliasName, headers, runtime);
    }
    async deleteAliasWithOptions(serviceName, aliasName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        aliasName = openapi_util_1.default.getEncodeParam(aliasName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteAlias",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/aliases/${aliasName}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteAliasResponse({}));
    }
    async deleteCustomDomain(domainName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteCustomDomainHeaders({});
        return await this.deleteCustomDomainWithOptions(domainName, headers, runtime);
    }
    async deleteCustomDomainWithOptions(domainName, headers, runtime) {
        domainName = openapi_util_1.default.getEncodeParam(domainName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteCustomDomain",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/custom-domains/${domainName}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteCustomDomainResponse({}));
    }
    async deleteFunction(serviceName, functionName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteFunctionHeaders({});
        return await this.deleteFunctionWithOptions(serviceName, functionName, headers, runtime);
    }
    async deleteFunctionWithOptions(serviceName, functionName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteFunction",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteFunctionResponse({}));
    }
    async deleteFunctionAsyncInvokeConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteFunctionAsyncInvokeConfigHeaders({});
        return await this.deleteFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async deleteFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteFunctionAsyncInvokeConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteFunctionAsyncInvokeConfigResponse({}));
    }
    async deleteFunctionOnDemandConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteFunctionOnDemandConfigHeaders({});
        return await this.deleteFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async deleteFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteFunctionOnDemandConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteFunctionOnDemandConfigResponse({}));
    }
    async deleteLayerVersion(layerName, version) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteLayerVersionHeaders({});
        return await this.deleteLayerVersionWithOptions(layerName, version, headers, runtime);
    }
    async deleteLayerVersionWithOptions(layerName, version, headers, runtime) {
        layerName = openapi_util_1.default.getEncodeParam(layerName);
        version = openapi_util_1.default.getEncodeParam(version);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteLayerVersion",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/layers/${layerName}/versions/${version}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteLayerVersionResponse({}));
    }
    async deleteService(serviceName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteServiceHeaders({});
        return await this.deleteServiceWithOptions(serviceName, headers, runtime);
    }
    async deleteServiceWithOptions(serviceName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteService",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteServiceResponse({}));
    }
    async deleteServiceVersion(serviceName, versionId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteServiceVersionHeaders({});
        return await this.deleteServiceVersionWithOptions(serviceName, versionId, headers, runtime);
    }
    async deleteServiceVersionWithOptions(serviceName, versionId, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        versionId = openapi_util_1.default.getEncodeParam(versionId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteServiceVersion",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/versions/${versionId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteServiceVersionResponse({}));
    }
    async deleteTrigger(serviceName, functionName, triggerName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteTriggerHeaders({});
        return await this.deleteTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
    }
    async deleteTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        triggerName = openapi_util_1.default.getEncodeParam(triggerName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteTrigger",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteTriggerResponse({}));
    }
    async deleteVpcBinding(serviceName, vpcId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteVpcBindingHeaders({});
        return await this.deleteVpcBindingWithOptions(serviceName, vpcId, headers, runtime);
    }
    async deleteVpcBindingWithOptions(serviceName, vpcId, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        vpcId = openapi_util_1.default.getEncodeParam(vpcId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteVpcBinding",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/bindings/${vpcId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteVpcBindingResponse({}));
    }
    async deregisterEventSource(serviceName, functionName, sourceArn, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeregisterEventSourceHeaders({});
        return await this.deregisterEventSourceWithOptions(serviceName, functionName, sourceArn, request, headers, runtime);
    }
    async deregisterEventSourceWithOptions(serviceName, functionName, sourceArn, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        sourceArn = openapi_util_1.default.getEncodeParam(sourceArn);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeregisterEventSource",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/event-sources/${sourceArn}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeregisterEventSourceResponse({}));
    }
    async getAccountSettings() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAccountSettingsHeaders({});
        return await this.getAccountSettingsWithOptions(headers, runtime);
    }
    async getAccountSettingsWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetAccountSettings",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/account-settings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAccountSettingsResponse({}));
    }
    async getAlias(serviceName, aliasName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAliasHeaders({});
        return await this.getAliasWithOptions(serviceName, aliasName, headers, runtime);
    }
    async getAliasWithOptions(serviceName, aliasName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        aliasName = openapi_util_1.default.getEncodeParam(aliasName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetAlias",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/aliases/${aliasName}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAliasResponse({}));
    }
    async getCustomDomain(domainName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCustomDomainHeaders({});
        return await this.getCustomDomainWithOptions(domainName, headers, runtime);
    }
    async getCustomDomainWithOptions(domainName, headers, runtime) {
        domainName = openapi_util_1.default.getEncodeParam(domainName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetCustomDomain",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/custom-domains/${domainName}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetCustomDomainResponse({}));
    }
    async getFunction(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFunctionHeaders({});
        return await this.getFunctionWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async getFunctionWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFunction",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetFunctionResponse({}));
    }
    async getFunctionAsyncInvokeConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFunctionAsyncInvokeConfigHeaders({});
        return await this.getFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async getFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFunctionAsyncInvokeConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetFunctionAsyncInvokeConfigResponse({}));
    }
    async getFunctionCode(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFunctionCodeHeaders({});
        return await this.getFunctionCodeWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async getFunctionCodeWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFunctionCode",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/code`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetFunctionCodeResponse({}));
    }
    async getFunctionOnDemandConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFunctionOnDemandConfigHeaders({});
        return await this.getFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async getFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFunctionOnDemandConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetFunctionOnDemandConfigResponse({}));
    }
    async getLayerVersion(layerName, version) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetLayerVersionHeaders({});
        return await this.getLayerVersionWithOptions(layerName, version, headers, runtime);
    }
    async getLayerVersionWithOptions(layerName, version, headers, runtime) {
        layerName = openapi_util_1.default.getEncodeParam(layerName);
        version = openapi_util_1.default.getEncodeParam(version);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetLayerVersion",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/layers/${layerName}/versions/${version}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetLayerVersionResponse({}));
    }
    async getProvisionConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetProvisionConfigHeaders({});
        return await this.getProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async getProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetProvisionConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/provision-config`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetProvisionConfigResponse({}));
    }
    async getResourceTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetResourceTagsHeaders({});
        return await this.getResourceTagsWithOptions(request, headers, runtime);
    }
    async getResourceTagsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.resourceArn)) {
            query["resourceArn"] = request.resourceArn;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetResourceTags",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/tag`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetResourceTagsResponse({}));
    }
    async getService(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetServiceHeaders({});
        return await this.getServiceWithOptions(serviceName, request, headers, runtime);
    }
    async getServiceWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetService",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetServiceResponse({}));
    }
    async getStatefulAsyncInvocation(serviceName, functionName, invocationId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetStatefulAsyncInvocationHeaders({});
        return await this.getStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
    }
    async getStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        invocationId = openapi_util_1.default.getEncodeParam(invocationId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcCodeChecksum)) {
            realHeaders["X-Fc-Code-Checksum"] = tea_util_1.default.toJSONString(headers.xFcCodeChecksum);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcInvocationType)) {
            realHeaders["X-Fc-Invocation-Type"] = tea_util_1.default.toJSONString(headers.xFcInvocationType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcLogType)) {
            realHeaders["X-Fc-Log-Type"] = tea_util_1.default.toJSONString(headers.xFcLogType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetStatefulAsyncInvocation",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations/${invocationId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetStatefulAsyncInvocationResponse({}));
    }
    async getTrigger(serviceName, functionName, triggerName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTriggerHeaders({});
        return await this.getTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
    }
    async getTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        triggerName = openapi_util_1.default.getEncodeParam(triggerName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetTrigger",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetTriggerResponse({}));
    }
    async invokeFunction(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InvokeFunctionHeaders({});
        return await this.invokeFunctionWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async invokeFunctionWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcInvocationType)) {
            realHeaders["X-Fc-Invocation-Type"] = tea_util_1.default.toJSONString(headers.xFcInvocationType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcLogType)) {
            realHeaders["X-Fc-Log-Type"] = tea_util_1.default.toJSONString(headers.xFcLogType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcStatefulAsyncInvocationId)) {
            realHeaders["X-Fc-Stateful-Async-Invocation-Id"] = tea_util_1.default.toJSONString(headers.xFcStatefulAsyncInvocationId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toString(request.body),
        });
        let params = new $OpenApi.Params({
            action: "InvokeFunction",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/invocations`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "byte",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new InvokeFunctionResponse({}));
    }
    async listAliases(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAliasesHeaders({});
        return await this.listAliasesWithOptions(serviceName, request, headers, runtime);
    }
    async listAliasesWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListAliases",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/aliases`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListAliasesResponse({}));
    }
    async listCustomDomains(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListCustomDomainsHeaders({});
        return await this.listCustomDomainsWithOptions(request, headers, runtime);
    }
    async listCustomDomainsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListCustomDomains",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/custom-domains`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListCustomDomainsResponse({}));
    }
    async listEventSources(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListEventSourcesHeaders({});
        return await this.listEventSourcesWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async listEventSourcesWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListEventSources",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/event-sources`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListEventSourcesResponse({}));
    }
    async listFunctionAsyncInvokeConfigs(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListFunctionAsyncInvokeConfigsHeaders({});
        return await this.listFunctionAsyncInvokeConfigsWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async listFunctionAsyncInvokeConfigsWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcCodeChecksum)) {
            realHeaders["X-Fc-Code-Checksum"] = tea_util_1.default.toJSONString(headers.xFcCodeChecksum);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcInvocationType)) {
            realHeaders["X-Fc-Invocation-Type"] = tea_util_1.default.toJSONString(headers.xFcInvocationType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcLogType)) {
            realHeaders["X-Fc-Log-Type"] = tea_util_1.default.toJSONString(headers.xFcLogType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListFunctionAsyncInvokeConfigs",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-configs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListFunctionAsyncInvokeConfigsResponse({}));
    }
    async listFunctions(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListFunctionsHeaders({});
        return await this.listFunctionsWithOptions(serviceName, request, headers, runtime);
    }
    async listFunctionsWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListFunctions",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListFunctionsResponse({}));
    }
    async listInstances(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListInstancesHeaders({});
        return await this.listInstancesWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async listInstancesWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceIds)) {
            query["instanceIds"] = request.instanceIds;
        }
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListInstances",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/instances`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListInstancesResponse({}));
    }
    async listLayerVersions(layerName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListLayerVersionsHeaders({});
        return await this.listLayerVersionsWithOptions(layerName, request, headers, runtime);
    }
    async listLayerVersionsWithOptions(layerName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        layerName = openapi_util_1.default.getEncodeParam(layerName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.startVersion)) {
            query["startVersion"] = request.startVersion;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListLayerVersions",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/layers/${layerName}/versions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListLayerVersionsResponse({}));
    }
    async listLayers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListLayersHeaders({});
        return await this.listLayersWithOptions(request, headers, runtime);
    }
    async listLayersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListLayers",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/layers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListLayersResponse({}));
    }
    async listOnDemandConfigs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListOnDemandConfigsHeaders({});
        return await this.listOnDemandConfigsWithOptions(request, headers, runtime);
    }
    async listOnDemandConfigsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListOnDemandConfigs",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/on-demand-configs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListOnDemandConfigsResponse({}));
    }
    async listProvisionConfigs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListProvisionConfigsHeaders({});
        return await this.listProvisionConfigsWithOptions(request, headers, runtime);
    }
    async listProvisionConfigsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        if (!tea_util_1.default.isUnset(request.serviceName)) {
            query["serviceName"] = request.serviceName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListProvisionConfigs",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/provision-configs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListProvisionConfigsResponse({}));
    }
    async listReservedCapacities(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListReservedCapacitiesHeaders({});
        return await this.listReservedCapacitiesWithOptions(request, headers, runtime);
    }
    async listReservedCapacitiesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListReservedCapacities",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/reserved-capacities`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListReservedCapacitiesResponse({}));
    }
    async listServiceVersions(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListServiceVersionsHeaders({});
        return await this.listServiceVersionsWithOptions(serviceName, request, headers, runtime);
    }
    async listServiceVersionsWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListServiceVersions",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/versions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListServiceVersionsResponse({}));
    }
    async listServices(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListServicesHeaders({});
        return await this.listServicesWithOptions(request, headers, runtime);
    }
    async listServicesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListServices",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListServicesResponse({}));
    }
    async listStatefulAsyncInvocationFunctions(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListStatefulAsyncInvocationFunctionsHeaders({});
        return await this.listStatefulAsyncInvocationFunctionsWithOptions(request, headers, runtime);
    }
    async listStatefulAsyncInvocationFunctionsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListStatefulAsyncInvocationFunctions",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/stateful-async-invocation-functions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListStatefulAsyncInvocationFunctionsResponse({}));
    }
    async listStatefulAsyncInvocations(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListStatefulAsyncInvocationsHeaders({});
        return await this.listStatefulAsyncInvocationsWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async listStatefulAsyncInvocationsWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.includePayload)) {
            query["includePayload"] = request.includePayload;
        }
        if (!tea_util_1.default.isUnset(request.invocationIdPrefix)) {
            query["invocationIdPrefix"] = request.invocationIdPrefix;
        }
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        if (!tea_util_1.default.isUnset(request.sortOrderByTime)) {
            query["sortOrderByTime"] = request.sortOrderByTime;
        }
        if (!tea_util_1.default.isUnset(request.startedTimeBegin)) {
            query["startedTimeBegin"] = request.startedTimeBegin;
        }
        if (!tea_util_1.default.isUnset(request.startedTimeEnd)) {
            query["startedTimeEnd"] = request.startedTimeEnd;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcCodeChecksum)) {
            realHeaders["X-Fc-Code-Checksum"] = tea_util_1.default.toJSONString(headers.xFcCodeChecksum);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcInvocationType)) {
            realHeaders["X-Fc-Invocation-Type"] = tea_util_1.default.toJSONString(headers.xFcInvocationType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcLogType)) {
            realHeaders["X-Fc-Log-Type"] = tea_util_1.default.toJSONString(headers.xFcLogType);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListStatefulAsyncInvocations",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListStatefulAsyncInvocationsResponse({}));
    }
    async listTaggedResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListTaggedResourcesHeaders({});
        return await this.listTaggedResourcesWithOptions(request, headers, runtime);
    }
    async listTaggedResourcesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTaggedResources",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/tags`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListTaggedResourcesResponse({}));
    }
    async listTriggers(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListTriggersHeaders({});
        return await this.listTriggersWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async listTriggersWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.prefix)) {
            query["prefix"] = request.prefix;
        }
        if (!tea_util_1.default.isUnset(request.startKey)) {
            query["startKey"] = request.startKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTriggers",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListTriggersResponse({}));
    }
    async listVpcBindings(serviceName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListVpcBindingsHeaders({});
        return await this.listVpcBindingsWithOptions(serviceName, headers, runtime);
    }
    async listVpcBindingsWithOptions(serviceName, headers, runtime) {
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ListVpcBindings",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/bindings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListVpcBindingsResponse({}));
    }
    async publishServiceVersion(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PublishServiceVersionHeaders({});
        return await this.publishServiceVersionWithOptions(serviceName, request, headers, runtime);
    }
    async publishServiceVersionWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PublishServiceVersion",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/versions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PublishServiceVersionResponse({}));
    }
    async putFunctionAsyncInvokeConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PutFunctionAsyncInvokeConfigHeaders({});
        return await this.putFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async putFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.destinationConfig))) {
            body["destinationConfig"] = request.destinationConfig;
        }
        if (!tea_util_1.default.isUnset(request.maxAsyncEventAgeInSeconds)) {
            body["maxAsyncEventAgeInSeconds"] = request.maxAsyncEventAgeInSeconds;
        }
        if (!tea_util_1.default.isUnset(request.maxAsyncRetryAttempts)) {
            body["maxAsyncRetryAttempts"] = request.maxAsyncRetryAttempts;
        }
        if (!tea_util_1.default.isUnset(request.statefulInvocation)) {
            body["statefulInvocation"] = request.statefulInvocation;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PutFunctionAsyncInvokeConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PutFunctionAsyncInvokeConfigResponse({}));
    }
    async putFunctionOnDemandConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PutFunctionOnDemandConfigHeaders({});
        return await this.putFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async putFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.maximumInstanceCount)) {
            body["maximumInstanceCount"] = request.maximumInstanceCount;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PutFunctionOnDemandConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PutFunctionOnDemandConfigResponse({}));
    }
    async putProvisionConfig(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PutProvisionConfigHeaders({});
        return await this.putProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async putProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.alwaysAllocateCPU)) {
            body["alwaysAllocateCPU"] = request.alwaysAllocateCPU;
        }
        if (!tea_util_1.default.isUnset(request.scheduledActions)) {
            body["scheduledActions"] = request.scheduledActions;
        }
        if (!tea_util_1.default.isUnset(request.target)) {
            body["target"] = request.target;
        }
        if (!tea_util_1.default.isUnset(request.targetTrackingPolicies)) {
            body["targetTrackingPolicies"] = request.targetTrackingPolicies;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PutProvisionConfig",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/provision-config`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PutProvisionConfigResponse({}));
    }
    async registerEventSource(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RegisterEventSourceHeaders({});
        return await this.registerEventSourceWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async registerEventSourceWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.sourceArn)) {
            body["sourceArn"] = request.sourceArn;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RegisterEventSource",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/event-sources`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RegisterEventSourceResponse({}));
    }
    async stopStatefulAsyncInvocation(serviceName, functionName, invocationId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopStatefulAsyncInvocationHeaders({});
        return await this.stopStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
    }
    async stopStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        invocationId = openapi_util_1.default.getEncodeParam(invocationId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            query["qualifier"] = request.qualifier;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StopStatefulAsyncInvocation",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations/${invocationId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StopStatefulAsyncInvocationResponse({}));
    }
    async tagResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TagResourceHeaders({});
        return await this.tagResourceWithOptions(request, headers, runtime);
    }
    async tagResourceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.resourceArn)) {
            body["resourceArn"] = request.resourceArn;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TagResource",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/tag`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TagResourceResponse({}));
    }
    async untagResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UntagResourceHeaders({});
        return await this.untagResourceWithOptions(request, headers, runtime);
    }
    async untagResourceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.all)) {
            body["all"] = request.all;
        }
        if (!tea_util_1.default.isUnset(request.resourceArn)) {
            body["resourceArn"] = request.resourceArn;
        }
        if (!tea_util_1.default.isUnset(request.tagKeys)) {
            body["tagKeys"] = request.tagKeys;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UntagResource",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/tag`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UntagResourceResponse({}));
    }
    async updateAlias(serviceName, aliasName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateAliasHeaders({});
        return await this.updateAliasWithOptions(serviceName, aliasName, request, headers, runtime);
    }
    async updateAliasWithOptions(serviceName, aliasName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        aliasName = openapi_util_1.default.getEncodeParam(aliasName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.additionalVersionWeight)) {
            body["additionalVersionWeight"] = request.additionalVersionWeight;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.versionId)) {
            body["versionId"] = request.versionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateAlias",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/aliases/${aliasName}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateAliasResponse({}));
    }
    async updateCustomDomain(domainName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateCustomDomainHeaders({});
        return await this.updateCustomDomainWithOptions(domainName, request, headers, runtime);
    }
    async updateCustomDomainWithOptions(domainName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        domainName = openapi_util_1.default.getEncodeParam(domainName);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.certConfig))) {
            body["certConfig"] = request.certConfig;
        }
        if (!tea_util_1.default.isUnset(request.protocol)) {
            body["protocol"] = request.protocol;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.routeConfig))) {
            body["routeConfig"] = request.routeConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.tlsConfig))) {
            body["tlsConfig"] = request.tlsConfig;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateCustomDomain",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/custom-domains/${domainName}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateCustomDomainResponse({}));
    }
    async updateFunction(serviceName, functionName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateFunctionHeaders({});
        return await this.updateFunctionWithOptions(serviceName, functionName, request, headers, runtime);
    }
    async updateFunctionWithOptions(serviceName, functionName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.instanceConcurrency)) {
            body["InstanceConcurrency"] = request.instanceConcurrency;
        }
        if (!tea_util_1.default.isUnset(request.caPort)) {
            body["caPort"] = request.caPort;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.code))) {
            body["code"] = request.code;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.customContainerConfig))) {
            body["customContainerConfig"] = request.customContainerConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.customDNS))) {
            body["customDNS"] = request.customDNS;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.customRuntimeConfig))) {
            body["customRuntimeConfig"] = request.customRuntimeConfig;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.environmentVariables)) {
            body["environmentVariables"] = request.environmentVariables;
        }
        if (!tea_util_1.default.isUnset(request.handler)) {
            body["handler"] = request.handler;
        }
        if (!tea_util_1.default.isUnset(request.initializationTimeout)) {
            body["initializationTimeout"] = request.initializationTimeout;
        }
        if (!tea_util_1.default.isUnset(request.initializer)) {
            body["initializer"] = request.initializer;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.instanceLifecycleConfig))) {
            body["instanceLifecycleConfig"] = request.instanceLifecycleConfig;
        }
        if (!tea_util_1.default.isUnset(request.instanceSoftConcurrency)) {
            body["instanceSoftConcurrency"] = request.instanceSoftConcurrency;
        }
        if (!tea_util_1.default.isUnset(request.instanceType)) {
            body["instanceType"] = request.instanceType;
        }
        if (!tea_util_1.default.isUnset(request.layers)) {
            body["layers"] = request.layers;
        }
        if (!tea_util_1.default.isUnset(request.memorySize)) {
            body["memorySize"] = request.memorySize;
        }
        if (!tea_util_1.default.isUnset(request.runtime)) {
            body["runtime"] = request.runtime;
        }
        if (!tea_util_1.default.isUnset(request.timeout)) {
            body["timeout"] = request.timeout;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcCodeChecksum)) {
            realHeaders["X-Fc-Code-Checksum"] = tea_util_1.default.toJSONString(headers.xFcCodeChecksum);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateFunction",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateFunctionResponse({}));
    }
    async updateService(serviceName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateServiceHeaders({});
        return await this.updateServiceWithOptions(serviceName, request, headers, runtime);
    }
    async updateServiceWithOptions(serviceName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.internetAccess)) {
            body["internetAccess"] = request.internetAccess;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.logConfig))) {
            body["logConfig"] = request.logConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.nasConfig))) {
            body["nasConfig"] = request.nasConfig;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.tracingConfig))) {
            body["tracingConfig"] = request.tracingConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.vpcConfig))) {
            body["vpcConfig"] = request.vpcConfig;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateService",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateServiceResponse({}));
    }
    async updateTrigger(serviceName, functionName, triggerName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateTriggerHeaders({});
        return await this.updateTriggerWithOptions(serviceName, functionName, triggerName, request, headers, runtime);
    }
    async updateTriggerWithOptions(serviceName, functionName, triggerName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        serviceName = openapi_util_1.default.getEncodeParam(serviceName);
        functionName = openapi_util_1.default.getEncodeParam(functionName);
        triggerName = openapi_util_1.default.getEncodeParam(triggerName);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.invocationRole)) {
            body["invocationRole"] = request.invocationRole;
        }
        if (!tea_util_1.default.isUnset(request.qualifier)) {
            body["qualifier"] = request.qualifier;
        }
        if (!tea_util_1.default.isUnset(request.triggerConfig)) {
            body["triggerConfig"] = request.triggerConfig;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.ifMatch)) {
            realHeaders["If-Match"] = tea_util_1.default.toJSONString(headers.ifMatch);
        }
        if (!tea_util_1.default.isUnset(headers.xFcAccountId)) {
            realHeaders["X-Fc-Account-Id"] = tea_util_1.default.toJSONString(headers.xFcAccountId);
        }
        if (!tea_util_1.default.isUnset(headers.xFcDate)) {
            realHeaders["X-Fc-Date"] = tea_util_1.default.toJSONString(headers.xFcDate);
        }
        if (!tea_util_1.default.isUnset(headers.xFcTraceId)) {
            realHeaders["X-Fc-Trace-Id"] = tea_util_1.default.toJSONString(headers.xFcTraceId);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTrigger",
            version: "2021-04-06",
            protocol: "HTTPS",
            pathname: `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateTriggerResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map